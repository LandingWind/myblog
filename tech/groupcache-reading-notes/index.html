<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Groupcache源码阅读笔记 - Melon</title><meta name="Description" content=""><meta property="og:title" content="Groupcache源码阅读笔记" />
<meta property="og:description" content="GroupCache源码阅读的一些笔记 同步到了repo lru 总体而言实现方式为双向链表&#43;map 主要逻辑如下： 添加一个新key/或者更新已有key" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.joyinn.top/tech/groupcache-reading-notes/" />
<meta property="article:published_time" content="2020-04-04T21:47:52+08:00" />
<meta property="article:modified_time" content="2020-04-04T21:47:52+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Groupcache源码阅读笔记"/>
<meta name="twitter:description" content="GroupCache源码阅读的一些笔记 同步到了repo lru 总体而言实现方式为双向链表&#43;map 主要逻辑如下： 添加一个新key/或者更新已有key"/>
<meta name="application-name" content="Melon">
<meta name="apple-mobile-web-app-title" content="Melon"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://blog.joyinn.top/tech/groupcache-reading-notes/" /><link rel="prev" href="https://blog.joyinn.top/tech/hugo-docker-webhooks-best-practice/" /><link rel="next" href="https://blog.joyinn.top/tech/react-reading-notes/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.2e7125082ec8de83a87adc70253c9c23.css" integrity="md5-LnElCC7I3oOoetxwJTycIw=="><link rel="stylesheet" href="/css/style.min.ac0f5ed27fd6fe5c5b9c11daee3fd2ac.css" integrity="md5-rA9e0n/W/lxbnBHa7j/SrA=="><link rel="stylesheet" href="/lib/fontawesome-free/all.min.76cb46c10b6c0293433b371bae2414b2.css" integrity="md5-dstGwQtsApNDOzcbriQUsg=="><link rel="stylesheet" href="/lib/animate/animate.min.bc1a6a99c43f5ccc97d2d350bde13f74.css" integrity="md5-vBpqmcQ/XMyX0tNQveE/dA=="><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Groupcache源码阅读笔记",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/blog.joyinn.top\/tech\/groupcache-reading-notes\/"
        },"genre": "tech","keywords": "cache, 一致性哈希, singleflight","wordcount":  3122 ,
        "url": "https:\/\/blog.joyinn.top\/tech\/groupcache-reading-notes\/","datePublished": "2020-04-04T21:47:52+08:00","dateModified": "2020-04-04T21:47:52+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "wkk"
            },"description": ""
    }
    </script></head>
    <body header-desktop="auto" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Melon">Melon</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/tech"> Tech </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Melon">Melon</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/tech" title="">Tech</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="page single special"><h1 class="single-title animated pulse faster">Groupcache源码阅读笔记</h1><div class="content" id="content"><p>GroupCache源码阅读的一些笔记 同步到了<a href="https://github.com/wkk5194/groupcache" target="_blank" rel="noopener noreffer">repo</a></p>
<h2 id="lru">lru</h2>
<p>总体而言实现方式为<code>双向链表</code>+<code>map</code></p>
<p>主要逻辑如下：</p>
<ul>
<li>添加一个新key/或者更新已有key，将key对应的element执行PushFront/MoveToFront操作，也就是放到链表最前，然后判断是否超过了最大容量，超过就删除链表最末element</li>
<li>查询一个key，同样执行MoveToFront操作</li>
<li>此外当key-element被删除的时候，源码显示可以执行OnEvicted操作，但是似乎在lru cache注册阶段没有写对这个回调函数的注入（???）</li>
</ul>
<p>缺点的话：主要就是依赖的container/list是线程不安全的，不支持并行，效率有点低，外部需要维护一下同步的问题</p>
<h2 id="consistenthash">consistenthash</h2>
<p>一致性哈希 实现方式就是根据理论来</p>
<p>主要逻辑如下：</p>
<ul>
<li>为了hash ring上节点能尽可能平均分布，因此允许虚拟节点，为此传入replicas表示总节点数=实节点*replicas</li>
<li>hash函数允许自定义，默认的hash函数为crc32，crc是一种追求速度不追求低碰撞率的hash算法，具体可以看<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" target="_blank" rel="noopener noreffer">wiki</a></li>
<li>对虚拟节点的处理通过加前置index再hash</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">.</span><span class="nx">replicas</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">hash</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">hash</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">+</span> <span class="nx">key</span><span class="p">)))</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">keys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">hash</span><span class="p">)</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">hashMap</span><span class="p">[</span><span class="nx">hash</span><span class="p">]</span> <span class="p">=</span> <span class="nx">key</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>放进去的keys为了接下来在get的时候找到最近，需要进行排序，源码直接根据hash的字母序排序</li>
<li>get某个key的时候就是寻找key对应的hash在hash ring上距离最近的节点，源码用的是sort.Search，一个sort依赖模块的二分查找方法</li>
</ul>
<p>源码没有写对key的remove操作，难道要clear掉重新add吗</p>
<h2 id="singleflight">singleflight</h2>
<p>这个模块实现的功能可以说是groupcache的一大亮点，而且代码量极小</p>
<p>当get请求的key找不到的时候，并发的相同的get请求可能会击穿缓存</p>
<p>通过singleflight对并发相同key的get请求进行拦截，那么真正只会去get一个（无论是去peer还是怎样），其他就可以直接返回</p>
<p>结合代码看一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">call</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">wg</span>  <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">val</span> <span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">err</span> <span class="kt">error</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Group</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>       
	<span class="nx">m</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">call</span> 
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">()</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">))</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">g</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">call</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">call</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">c</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nx">c</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nf">fn</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>

	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">m</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
	<span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>对Group的操作通过mutex锁保护起来</li>
<li>每一个key都有一个call，内部有wg锁来阻塞</li>
<li>当命中key的时候，wg wait，也就是被阻塞住直到执行阻塞的第一次get返回了值</li>
<li>如果没有命中key，那就是第一次get这个key，所以新建一个call，然后wg add 1，然后执行fn函数去取得值，最后wg done释放阻塞</li>
<li>记得用完要把这个key删掉哦 不然下次进来直接命中key而且无阻塞返回val了，导致错误</li>
</ul>
<p>代码短小精悍，对并发的控制却是精妙绝伦！</p>
<h2 id="groupcachepb">groupcachepb</h2>
<p>pb就是protobuf的简写，所以这就是一个提供通信的模块，利用protobuf做序列化和反序列化</p>
<p>里面有groupcache.pb.go和groupcache.proto两个文件，其实就是编写了proto文件然后利用protobuf生成go文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">message</span> <span class="nx">GetRequest</span> <span class="p">{</span>
  <span class="nx">required</span> <span class="kt">string</span> <span class="nx">group</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">required</span> <span class="kt">string</span> <span class="nx">key</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// not actually required/guaranteed to be UTF-8
</span><span class="c1"></span><span class="p">}</span>

<span class="nx">message</span> <span class="nx">GetResponse</span> <span class="p">{</span>
  <span class="nx">optional</span> <span class="nx">bytes</span> <span class="nx">value</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">optional</span> <span class="nx">double</span> <span class="nx">minute_qps</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">service</span> <span class="nx">GroupCache</span> <span class="p">{</span>
  <span class="nx">rpc</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">GetRequest</span><span class="p">)</span> <span class="nf">returns</span> <span class="p">(</span><span class="nx">GetResponse</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>具体去看proto文件，定义了request和response的一些字段，还定义了rpc通信接口</p>
<h2 id="byteview-and-sinks">byteview and sinks</h2>
<p>byteview模块封装了一个string与byte[] 的统一接口，也就是说用byteview提供的接口，可以屏蔽掉string与byte[] 的不同，使用时可以不用考虑是string还是byte[]</p>
<p>然后sinks模块在其基础上实现了几个sinks struct，相当于做了数据的储存，可以set；可以view；setproto方法是用来从protobuf的message中把数据sink下来</p>
<p>这里涉及到的代码重复度比较高，几个struct逻辑都是基本相同的，在此不赘述</p>
<h2 id="peers-and-http">peers and http</h2>
<p>这两个模块就完成了peer的分工和协作</p>
<p>先看peer模块，我们这里就不管nopeers的部分了（也没有什么东西），直接看peers</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ProtoGetter</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">GetRequest</span><span class="p">,</span> <span class="nx">out</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">GetResponse</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">PeerPicker</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">PickPeer</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">peer</span> <span class="nx">ProtoGetter</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>定义了两个个接口，关注一下PeerPicker接口，用于在给定key的时候返回处理这个key的peer，类型是protogetter，也就是第一个interface</p>
<p>那么相对应的pickpeer注册如下（可以看到只能注入一次）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">portPicker</span> <span class="kd">func</span><span class="p">(</span><span class="nx">groupName</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">PeerPicker</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">RegisterPeerPicker</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">PeerPicker</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">portPicker</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;RegisterPeerPicker called more than once&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">portPicker</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">PeerPicker</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">fn</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注册完如何找到key对应peer的函数，在groupcache调用getPeers如下的时候可以查找到peer</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getPeers</span><span class="p">(</span><span class="nx">groupName</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">PeerPicker</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">portPicker</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">NoPeers</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="nx">pk</span> <span class="o">:=</span> <span class="nf">portPicker</span><span class="p">(</span><span class="nx">groupName</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">pk</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">pk</span> <span class="p">=</span> <span class="nx">NoPeers</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">pk</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后看相对比较复杂的http模块</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">HTTPPool</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Context</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
	<span class="nx">Transport</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">RoundTripper</span>
	<span class="c1">// this peer&#39;s base URL, e.g. &#34;https://example.net:8000&#34;
</span><span class="c1"></span>	<span class="nx">self</span> <span class="kt">string</span>
	<span class="c1">// opts specifies the options.
</span><span class="c1"></span>	<span class="nx">opts</span> <span class="nx">HTTPPoolOptions</span>

	<span class="nx">mu</span>          <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// guards peers and httpGetters
</span><span class="c1"></span>	<span class="nx">peers</span>       <span class="o">*</span><span class="nx">consistenthash</span><span class="p">.</span><span class="nx">Map</span>
	<span class="nx">httpGetters</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">httpGetter</span> <span class="c1">// keyed by e.g. &#34;http://10.0.0.2:8008&#34;
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">type</span> <span class="nx">HTTPPoolOptions</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">BasePath</span> <span class="kt">string</span>
	<span class="nx">Replicas</span> <span class="kt">int</span>
	<span class="nx">HashFn</span> <span class="nx">consistenthash</span><span class="p">.</span><span class="nx">Hash</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>有上述的options参与定义httppool，所以用到了consistent hash，也就是存放peers hash对应的数据结构，所以会将peers加入到consistent hash中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">httpGetter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">transport</span> <span class="kd">func</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="nx">http</span><span class="p">.</span><span class="nx">RoundTripper</span>
	<span class="nx">baseURL</span>   <span class="kt">string</span>
<span class="p">}</span>
<span class="c1">// ... other code
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">HTTPPool</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">peers</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">peers</span> <span class="p">=</span> <span class="nx">consistenthash</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">Replicas</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">HashFn</span><span class="p">)</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">peers</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">peers</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">httpGetters</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">httpGetter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">peers</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">peer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">peers</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">httpGetters</span><span class="p">[</span><span class="nx">peer</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">httpGetter</span><span class="p">{</span><span class="nx">transport</span><span class="p">:</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Transport</span><span class="p">,</span> <span class="nx">baseURL</span><span class="p">:</span> <span class="nx">peer</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">BasePath</span><span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们关注到httpGetter是实际处理通信的，源码这里的transport是一个可自定义的通信函数，默认使用 http.DefaultTransport</p>
<p>那么httpGetter是怎样的呢？其实就是通过protobuf发送get请求</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">httpGetter</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">GetRequest</span><span class="p">,</span> <span class="nx">out</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">GetResponse</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">u</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span>
		<span class="s">&#34;%v%v/%v&#34;</span><span class="p">,</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">baseURL</span><span class="p">,</span>
		<span class="nx">url</span><span class="p">.</span><span class="nf">QueryEscape</span><span class="p">(</span><span class="nx">in</span><span class="p">.</span><span class="nf">GetGroup</span><span class="p">()),</span>
		<span class="nx">url</span><span class="p">.</span><span class="nf">QueryEscape</span><span class="p">(</span><span class="nx">in</span><span class="p">.</span><span class="nf">GetKey</span><span class="p">()),</span>
	<span class="p">)</span>
	<span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="nx">u</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">req</span> <span class="p">=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">WithContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="nx">tr</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultTransport</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">transport</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">tr</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">transport</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tr</span><span class="p">.</span><span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">res</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">res</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">!=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;server returned: %v&#34;</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">Status</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nx">bufferPool</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="o">*</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">bufferPool</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;reading response body: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(),</span> <span class="nx">out</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;decoding response body: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>那peer作为客户端发送get请求，作为服务端还要响应get请求吧，所以又有如下的handle处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">HTTPPool</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Parse request.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">BasePath</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;HTTPPool serving unexpected path: &#34;</span> <span class="o">+</span> <span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">parts</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">SplitN</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">opts</span><span class="p">.</span><span class="nx">BasePath</span><span class="p">):],</span> <span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">parts</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">{</span>
		<span class="nx">http</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;bad request&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">groupName</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

	<span class="c1">// Fetch the value for this group/key.
</span><span class="c1"></span>	<span class="nx">group</span> <span class="o">:=</span> <span class="nf">GetGroup</span><span class="p">(</span><span class="nx">groupName</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">group</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">http</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;no such group: &#34;</span><span class="o">+</span><span class="nx">groupName</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Context</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ctx</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Context</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">ctx</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Context</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">group</span><span class="p">.</span><span class="nx">Stats</span><span class="p">.</span><span class="nx">ServerRequests</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">value</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">group</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nf">AllocatingByteSliceSink</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">http</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Write the value to the response body as a proto message.
</span><span class="c1"></span>	<span class="nx">body</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">proto</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pb</span><span class="p">.</span><span class="nx">GetResponse</span><span class="p">{</span><span class="nx">Value</span><span class="p">:</span> <span class="nx">value</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">http</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;application/x-protobuf&#34;</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">body</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="groupcache">groupcache</h2>
<p>接下来是控制中心 groupcache.go</p>
<p>抛开一切次要代码 先看一下group结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Group</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span>       <span class="kt">string</span>
	<span class="nx">getter</span>     <span class="nx">Getter</span>
	<span class="nx">peersOnce</span>  <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">peers</span>      <span class="nx">PeerPicker</span>
	<span class="nx">cacheBytes</span> <span class="kt">int64</span> 
	<span class="nx">mainCache</span> <span class="nx">cache</span>
	<span class="nx">hotCache</span> <span class="nx">cache</span>
	<span class="nx">loadGroup</span> <span class="nx">flightGroup</span>
	<span class="nx">_</span> <span class="kt">int32</span>
	<span class="nx">Stats</span> <span class="nx">Stats</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>源码其实注解得相当清楚：</p>
<ul>
<li>name对应group标识符</li>
<li>getter是获取val的处理函数</li>
<li>peers是peer groups的集合，实现了peerpicker接口</li>
<li>cacheBytes 决定了cache的大小</li>
<li>mainCache是当前group的缓存区</li>
<li>hotCache是从其他group查询后迁移过来的缓存</li>
<li>loadGroup避免缓冲击穿</li>
<li>Stats维护了缓存的状态数据，包括查询热点等等</li>
</ul>
<p>主要逻辑是酱：</p>
<ul>
<li>初始化peers</li>
<li>先在本地的mainCache和hotCache查询，找到就返回</li>
<li>找不到的话去peers中查询，用哪一个peer通过peerPicker，内部由consistenthash实现，然后迁移到hotcache</li>
<li>如果peers还没有，那就去再下一层的数据库或者文件查找（数据源的定义和操作都是自定义的）</li>
<li>中间为了避免缓存击穿，使用了singleflight</li>
<li>cache每次操作key后都会根据lru更新</li>
</ul>
</div></div></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by Hugo | Theme is LoveIt
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/landingwind" target="_blank">wkk</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.4afae7d446ba01ebf7fff19893eaf3a1.css" integrity="md5-Svrn1Ea6Aev3//GYk&#43;rzoQ=="><link rel="stylesheet" href="/lib/katex/copy-tex.min.b1994d1b9785dd8801dbf655df7bf6d9.css" integrity="md5-sZlNG5eF3YgB2/ZV33v22Q=="><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.acf82ee47549fdc386d02768992a49ad.css" integrity="md5-rPgu5HVJ/cOG0CdomSpJrQ=="><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.100efdceabf7a138f3297e437d078f74.js" integrity="md5-EA79zqv3oTjzKX5DfQePdA=="></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.b80e49640d4794d4333d00db76ea22f7.js" integrity="md5-uA5JZA1HlNQzPQDbduoi9w=="></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.af8ab36589315582ccdd82f22e84bffb.js" integrity="md5-r4qzZYkxVYLM3YLyLoS/&#43;w=="></script><script type="text/javascript" src="/lib/katex/katex.min.c158c9e823b681cf535f46596b5e4eac.js" integrity="md5-wVjJ6CO2gc9TX0ZZa15OrA=="></script><script type="text/javascript" src="/lib/katex/auto-render.min.28cd0b98cd3f4fa37d52f3ffe47ad9d4.js" integrity="md5-KM0LmM0/T6N9UvP/5HrZ1A=="></script><script type="text/javascript" src="/lib/katex/copy-tex.min.bfaec7d1dea915d74a7a6d833f0ff62e.js" integrity="md5-v67H0d6pFddKem2DPw/2Lg=="></script><script type="text/javascript" src="/lib/katex/mhchem.min.1bbb252363e83547d4b2186a41eaca28.js" integrity="md5-G7slI2PoNUfUshhqQerKKA=="></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.4a48532bf0b17c058b8b6854f49de23f.js" integrity="md5-SkhTK/CxfAWLi2hU9J3iPw=="></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":50},"comment":{},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.7bc7989e979c4a19d97db3ab311a80fe.js" integrity="md5-e8eYnpecShnZfbOrMRqA/g=="></script></body>
</html>
