# Actor模型


## actor概念

Actor模型是处理**并行计算**的概念模型。模型中一个Actor是一个基本的计算单元。它接受消息然后基于接到的消息做一些计算。和面向对象编程有些类似，一个对象被调用（接收到一个消息），基于调用方法（接受到的一个消息）做处理。区别是actor之间是**完全隔离**的，不共用内存区域。actor的私有状态不会被另外一个actor直接改变。

在actor模型中，actor是唯一组成部分，actor带有地址以便互相发送消息。

actor**按次序处理消息**，比如你发送三个消息给一个actor，它们不会被并发处理。如果你想让这三个消息得到并发处理，你需要创建3个actor，然后分别发送给它们。接受到的异步消息存在于actor内部的一个队列中，我们可以把它形象化的叫做邮箱。

{{<image src="http://qiniustorage.joyinn.top/blog/748527711.jpg" title="形象化邮箱逻辑">}}


简单来说，Actor通过消息传递的方式与外界通信，而且消息传递是异步的。每个Actor都有一个邮箱，邮箱接收并缓存其他Actor发过来的消息，通过邮箱队列`mail queue`来处理消息。Actor一次只能同步处理一个消息，处理消息过程中，除了可以接收消息外不能做任何其他操作。

每个Actor是完全独立的，可以同时执行他们的操作。每个Actor是一个计算实体，映射接收到的消息并执行以下动作：

- 发送有限个消息给其他Actor
- 创建有限个新的Actor
- 为下一个接收的消息指定行为

这三个动作没有固定的顺序，可以并发地执行，Actor会根据接收到的消息进行不同的处理。



## 进程间通信

把通信的线程可以想象成两个无法直接说话而必须通过邮件交流的人，双方要交流就要发送邮件。发送方邮件一旦发出就不能修改任何内容，而且是没有办法收回修改后再发的，这也就是消息一旦发出就不可改变。对于接收方而言，想什么时候看邮件就什么时候看，而且不需要监听，这就叫异步。接收方看了发送方的邮件可以回复也可以撒都不做。只是回复邮件一旦发出也同样是不能收回修改的，也就是不可变性两端都是一样的。同样，发送方针对回复邮件，也是想什么时候看就什么时候看。两端同样都是异步的。这种通信模型就是Actor想要的模型，可以发现这种通信方式其实依赖一套邮件系统或叫做消息管理系统。进程内部要有一套这样的系统，给每个线程一个独立的收发消息的管道，并且都是异步的。

##  并发性

并发导致最大的问题是对共享数据的操作，面对并发问题时多采用锁去保证共享数据的一致性，但同样也会带来一系列的副作用，比如要去考虑锁的粒度（对方法、程序块等）、锁的形式（读锁、写锁等）等问题。

传统的并发编程的方式大多使用锁机制，相信大多数都是悲观锁，这几乎可以断定会出现两个非常明显的问题：随着项目体量增大，业务愈加复杂，不可避免地会大量的使用锁，然而锁的机制其实是很低效的。即使大量依赖锁解决了项目中资源竞争的情况，但由于没有一个规范的编程模式，最后系统的稳定性肯定会出问题，最根本的原因是没有把系统的任务调度抽象出来，由于任务调度和业务逻辑耦合在一起，很难做一个很高层的抽象以保证任务调度有序性。

Actor模型为并发而生，是为解决高并发的一种编程思路。使用并发编程时需要特别关注锁与内存原子性等一系列的线程问题，Actor模型内部的状态由自身维护，也就是说Actor内部数据只能由它自己通过消息传递来进行状态修改，所以使用Actor模型可以很好地避免这些问题。



## 实例-买票场景

将计数器场景中基于线程的实现替换为`Actor`，当然`Actor`也要在线程中运行，但`Actor`只在有事情可做（没有消息要处理）的时候才会使用线程。

在计数器场景中，请求者代表`CutomerActor`，计数器数量由`TicketsActor`来维护并持有当前计数器的状态。`CustomerActor`和`TicketsActor`在空闲`idle`或没有事情做的时候都不会持有线程。

在初始购买操作时`CustomerActor`需要发送一个消息给`TicketsActor`，消息中包含了要购买的数量。当`TicketsActor`接收到消息时会校验购买数量是否超过库存数量，若合法则递减数量。此时`TicketsActor`会发送一条消息给`CutomerActor`表明订单被成功接受。若购买数量超过库存数量`TicketsActor`也会发送给`CustomerActor`一条消息，表明订单被拒绝。

可划分两个阶段的行为检查和递减操作，也可以通过同步操作序列来完成。但是基于`Actor`的实现不仅在每个`Actor`中提供了自然的操作同步，还能避免大量的线程积压，防止线程等待轮到它们执行同步代码区域。明显会降低系统资源的占用。

`Actor`模型本身确保处理是按照同步的方式执行的。`TicketsActor`会处理其收件箱中的每条消息，注意这里没有复杂的线程或锁，只是一个多线程的处理过程，但`Actor`系统会管理线程的使用和分配。



## 实例-寻找素数

### 传统锁方式

{{<image src="http://qiniustorage.joyinn.top/blog/2993046208.png" title="传统锁方式">}}


### Actor方式

{{<image src="http://qiniustorage.joyinn.top/blog/478379264.png" title="Actor方式">}}


## 另外

邮箱中的消息根据分类可以设置处理的优先级
