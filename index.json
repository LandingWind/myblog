[{"categories":["Web"],"content":"写在前面 Recoil作为React官方的试验性状态管理库，想法新颖 Hox作为蚂蚁体验技术部的成果，业务经验丰富 到底使用起来哪一个比较顺手呢？ 这是一篇不严谨的React state manager体验文 ","date":"2020-05-31","objectID":"/myblog/recoil-vs-hox/:0:1","tags":["hooks"],"title":"Recoil vs Hox","uri":"/myblog/recoil-vs-hox/"},{"categories":["Web"],"content":"概况对比 Recoil 源码在此 定义atom作为state数据源头，切割大state为最小单元 定义selector定义函数映射后的atom，相当于computed atom 从atom-selector-selector链路来看定义了一个state data flow map，但是要注意的是它实际是支持双向衍生的，也就是说数据流动可以是双向的，selector同样可以去set atom 所以，我们必须注意依赖循环！ Hox 基于原生的React Hooks——useState、useEffect进行state存储以及依赖更新 采用subscriber的数据订阅模式 此外通过Object.defineProperty进行获取状态数据时的拦截 推荐阅读其极其精简的源码 ","date":"2020-05-31","objectID":"/myblog/recoil-vs-hox/:0:2","tags":["hooks"],"title":"Recoil vs Hox","uri":"/myblog/recoil-vs-hox/"},{"categories":["Web"],"content":"TodoList Demo对比 通过实际案例来对比，显得极其清楚 我们做一个todolist 首先看看Recoil 源码 目录结构如下，mocker中存放了模拟后端数据，src/store文件存放了所有atom/selector recoil-todolist-codetree\" recoil-todolist-codetree 使用recoil的节点需要被包裹 \u003cRecoilRoot\u003e \u003cTodoList\u003e\u003c/TodoList\u003e \u003c/RecoilRoot\u003e 定义todolist state atom const listDataState = atom({ key: \"listDataState\", default: [ { id: 1, label: \"learn react and recoil\", visible: true, isDone: false }, { id: 2, label: \"play GTA5\", visible: true, isDone: true }, { id: 3, label: \"listen to music\", visible: true, isDone: false }, { id: 4, label: \"hangout with gf\", visible: true, isDone: true } ] }) 使用atom，然后展示 const [listData, setListData] = useRecoilState(listDataState); return ( \u003cdiv className=\"list\"\u003e \u003cul\u003e {filteredListData.map((item, index) =\u003e { return ( \u003cli key={index + md5(item.label)}\u003e\u003cTodoItem itemdata={item} /\u003e\u003c/li\u003e ) })} \u003c/ul\u003e \u003c/div\u003e // ...following code ) TodoItem中通过useSetRecoilState更新atom中数据，从而实现todolist的toggle、delete function getNewListData(id, listData) { const list = List(listData); return list.update( list.findIndex((value,_)=\u003evalue.id===id), (item)=\u003e{ return {...item, isDone: !item.isDone} } ); } function delFromListData(id, listData) { return listData.filter(item =\u003e item.id !== id); } function TodoBtn(id, isDone) { const listData = useRecoilValue(listDataState); const setListDataState = useSetRecoilState(listDataState); const type = !isDone ? \"done\" : \"redo\" return ( \u003cspan style={{ marginLeft: 30 }}\u003e \u003cbutton onClick={() =\u003e { setListDataState(getNewListData(id, listData)) }}\u003e{type}\u003c/button\u003e \u003cbutton onClick={() =\u003e { setListDataState(delFromListData(id, listData)) }}\u003edel\u003c/button\u003e \u003c/span\u003e ) } 定义筛选的state，及相关维护 // store.js const filterState = atom({ key: \"filterState\", default: \"all\" }) // TodoList.js const [filter, setFilter] = useRecoilState(filterState); // ... return ( \u003cselect value={filter} onChange={({ target: { value } }) =\u003e setFilter(value)}\u003e \u003coption value=\"all\"\u003eAll\u003c/option\u003e \u003coption value=\"completed\"\u003eCompleted\u003c/option\u003e \u003coption value=\"undos\"\u003eUncompleted\u003c/option\u003e \u003c/select\u003e ) 定义筛选后的todolist selector，依赖于原有的listdata atom和filter atom const filteredListState = selector({ key: \"filteredListState\", get: ({ get }) =\u003e { const filter = get(filterState); const list = get(listDataState); switch (filter) { case 'all': return list case 'undos': return list.filter((item) =\u003e !item.isDone); default: return list; } }, }) map的listdata替换为filteredListState 再来看看hox 源码 目录结构 Model中存放hox定义的state manager model hox-todolist-codetree\" hox-todolist-codetree useTodoModel中，将所有和todolist有关功能逻辑全部放在一块 import { useState } from 'react' import { createModel } from \"hox\"; import md5 from 'blueimp-md5' function useTodo() { const defaultTodos = [ { id: 1, label: \"learn react and recoil\",isDone: false }, { id: 2, label: \"play GTA5\",isDone: true }, { id: 3, label: \"listen to music\",isDone: false }, { id: 4, label: \"hangout with gf\",isDone: true } ] const [todos, setTodos] = useState(defaultTodos); const [filter, setFilter] = useState('all'); function addTodo(content) { setTodos([...todos, { id: md5(new Date().toTimeString()), label: content, isDone: false }]) } function delTodo(id) { setTodos(todos.filter(item =\u003e item.id !== id)) } function toggleTodo(id) { setTodos(todos.map(item =\u003e { if (item.id === id) { return { ...item, isDone: !item.isDone } } else { return item; } })) } function filteredTodo() { return todos.filter(item =\u003e { if(filter==='undos') { return !item.isDone; } if(filter==='completed') { return item.isDone; } return item; }) } return { todos: filteredTodo(), setTodos, addTodo, delTodo, toggleTodo, setFilter, filter } } export default createModel(useTodo); 接下来具体环境中就只是useTodoModel的接口调用，不予以赘述了… ","date":"2020-05-31","objectID":"/myblog/recoil-vs-hox/:0:3","tags":["hooks"],"title":"Recoil vs Hox","uri":"/myblog/recoil-vs-hox/"},{"categories":["Web"],"content":"思考 recoil 走的是学院派的路线： 将state切分最小化atom，定义selector构建媲美计算属性的依赖关系；这样一来可以轻松切割应用内功能模块，甚至可以在模块内继续切割，但是注意不利于抽离业务数据逻辑 主创人员显然走的是纯函数的思考模式，在处理副作用这一块使用起来不太方便，有一定缺陷，但是根据技术论坛消息有望在下一大版本迭代中更新 双向衍生数据，明晰的数据流动图，可追溯的时光机器以及手动定义key的方便数据持久化等等功能，学院派无疑，但是在业务中没有很大的用处，而且一些为了功能pure做出的妥协增加了开发的工作量，但是我们有希望看到recoil二次封装库解决这些问题 hox走的是符合用户习惯的路线： 实现方式采用原生react hook，使用起来只需一个API（部分依赖则需要两个API）极其精简 hox同样支持细粒度切分state（虽然不建议切分成atom这么细粒度），支持state依赖，支持归类业务数据逻辑并抽离出来（像是自定义了一个hook） 支持recoil还不支持的ts和class状态管理（recoil得下下大版本了吧） 也支持数据持久化，但是没有recoil手动模式这么定制化，可扩展的优化性没有那么高 总的来说hox目前还是优于recoil，API更友好，类umi的模式也十分有助于项目迁移。但是学院派recoil是值得尝试的道路，我们可以期待在recoil上二次封装适应业务开发表现。 ","date":"2020-05-31","objectID":"/myblog/recoil-vs-hox/:0:4","tags":["hooks"],"title":"Recoil vs Hox","uri":"/myblog/recoil-vs-hox/"},{"categories":["web"],"content":"尝试了最近拥抱hooks的react官方状态管理工具Recoil todolist demo代码仓库 ","date":"2020-05-25","objectID":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:0:0","tags":["react","recoil"],"title":"recoiljs 快速上手指南","uri":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["web"],"content":"recoiljs 快速上手指南 react官方的实验性状态管理库，拥抱hooks ","date":"2020-05-25","objectID":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:1:0","tags":["react","recoil"],"title":"recoiljs 快速上手指南","uri":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["web"],"content":"Problem 与react本身state管理相比… share state的问题，需要传到公共节点，以致于需要维护一个huge node tree，一个是麻烦复杂，一个是对于状态改变的重渲染不友好 一个context只能解决一个single value的生产消费问题 这两个问题导致代码不能细粒度拆分 ","date":"2020-05-25","objectID":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:1:1","tags":["react","recoil"],"title":"recoiljs 快速上手指南","uri":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["web"],"content":"Issue 定义了有向图（data-flow graph）来储存状态以及状态的依赖关系…（常规思路…）注意不用树是因为需要解决state的交叉依赖关系 ","date":"2020-05-25","objectID":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:1:2","tags":["react","recoil"],"title":"recoiljs 快速上手指南","uri":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["web"],"content":"Pros 符合react hook语法， boilerplate-free API 支持新出的Concurrent Mode 状态非常细粒度，方便代码切分 同步/异步数据来源的 state 不影响使用的组件的代码 state数据容易做持久化 开始一些概念… ","date":"2020-05-25","objectID":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:1:3","tags":["react","recoil"],"title":"recoiljs 快速上手指南","uri":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["web"],"content":"atom and selector atom，意即原子（努力把state拆分为最小粒度） const fontSizeState = atom({ key: 'fontSizeState', default: 14, }) 一旦atom中的state发生改变，使用atom的所有react组件都会被重新渲染 比起useState，key是用来调试、数据持久化、查看atom树的全局唯一值（不知道为什么不由recoil自己来生成… 使用atom用useRecoilState，用法和useState一致，毕竟是官方库 function FontButton() { const [fontSize, setFontSize] = useRecoilState(fontSizeState); return ( \u003cbutton onClick={() =\u003e setFontSize((size) =\u003e size + 1)} style={{fontSize}}\u003e Click to Enlarge \u003c/button\u003e ); } selector，输入atom或者其他selector，通过pure function映射数据，得到一个新的selector 其实atom就是特殊的selector，只是它是源数据节点 所有订阅了selector的组件当selector数据发生变动的时候同样会重新渲染 // data stream: // fontSizeState(atom) --\u003e fontSizeLabelState(selector) --\u003e react function component const fontSizeLabelState = selector({ key: 'fontSizeLabelState', get: ({get}) =\u003e { const fontSize = get(fontSizeState); const unit = 'px'; return `${fontSize}${unit}`; }, }); 由于selector是不可写的，所以我们使用useRecoilValue() function FontButton() { const [fontSize, setFontSize] = useRecoilState(fontSizeState); const fontSizeLabel = useRecoilValue(fontSizeLabelState); return ( \u003c\u003e \u003cdiv\u003eCurrent font size: ${fontSizeLabel}\u003c/div\u003e \u003cbutton onClick={() =\u003e setFontSize(fontSize + 1)} style={{fontSize}}\u003e Click to Enlarge \u003c/button\u003e \u003c/\u003e ); } 说到这里我们可以思考一下，其实如果单单谈论state依赖关系和数据流动，atom和selector是可以合并的 selector旨在做的是解决异步数据来源，就像redux-promise, redux-saga在redux中做的事情 但是从纯函数的角度来考虑，异步数据不应该嵌套在纯函数映射的data flow中，官方这样的解决方案让人存疑… ","date":"2020-05-25","objectID":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:1:4","tags":["react","recoil"],"title":"recoiljs 快速上手指南","uri":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["web"],"content":"demo code 写了一个简单的TodoList应用来看看怎么使用Recoil 完整代码链接 RecoilRoot 需要使用Recoil进行状态管理的Component，首先用RecoilRoot包裹。 注意：Recoil支持多个根例，会搜索最近的root function App() { return ( \u003cdiv className=\"App\" style={{textAlign:\"center\"}}\u003e \u003ch3\u003eThe TodoList based on React \u0026\u0026 Recoil\u003c/h3\u003e \u003cRecoilRoot\u003e \u003cTodoList\u003e\u003c/TodoList\u003e \u003c/RecoilRoot\u003e \u003c/div\u003e ); } atom定义和使用 首先定义listdata的atom，放在store文件夹下（当然想放哪里都可以，统一放在store中方便管理） const listDataState = atom({ key: \"listDataState\", default: [ { id: 1, label: \"learn react and recoil\", visible: true, isDone: false }, { id: 2, label: \"play GTA5\", visible: true, isDone: true }, { id: 3, label: \"listen to music\", visible: true, isDone: false }, { id: 4, label: \"hangout with gf\", visible: true, isDone: true } ] }) export {listDataState} 通过useRecoilState开始管理该atom，然后map一下list function todoList() { const [listData, setListData] = useRecoilState(listDataState); return ( \u003cdiv className=\"list\"\u003e \u003cul\u003e {listData.map((item, index) =\u003e { return ( \u003cli key={index + md5(item.label)}\u003e\u003cTodoItem itemdata={item} /\u003e\u003c/li\u003e ) })} \u003c/ul\u003e {/* other code */} \u003c/div\u003e ) } 修改state 然后我们现在想实现todolist的标记完成、添加、删除的功能，也就是对state进行修改 添加 // 在todoList中 \u003cspan\u003e \u003cinput value={inputData} onChange={(value) =\u003e setInputData(value.target.value)} placeholder=\"todo...\"\u003e \u003c/input\u003e \u003cbutton onClick={() =\u003e { const newListData = [...listData, cstrTodoItem(md5(inputData), inputData)]; setListData(newListData); setInputData(\"\"); }}\u003eAdd\u003c/button\u003e \u003c/span\u003e 删除、标记完成、标记未完成 // 在todoItem中 function getNewListData(id, listData) { const list = List(listData); return list.update( list.findIndex((value,_)=\u003evalue.id===id), (item)=\u003e{ return {...item, isDone: !item.isDone} } ); } function delFromListData(id, listData) { return listData.filter(item =\u003e item.id !== id); } function TodoBtn(id, isDone) { const listData = useRecoilValue(listDataState); const setListDataState = useSetRecoilState(listDataState); const type = !isDone ? \"done\" : \"redo\" return ( \u003cspan style={{ marginLeft: 30 }}\u003e \u003cbutton onClick={() =\u003e { setListDataState(getNewListData(id, listData)) }}\u003e{type}\u003c/button\u003e \u003cbutton onClick={() =\u003e { setListDataState(delFromListData(id, listData)) }}\u003edel\u003c/button\u003e \u003c/span\u003e ) } function TodoItem(props) { const { id, label, visible, isDone } = props.itemdata; return ( \u003cdiv className=\"item\"\u003e \u003cdiv\u003e {!isDone ? label : \u003cs\u003e{label}\u003c/s\u003e} \u003c/div\u003e \u003cdiv\u003e {TodoBtn(id, isDone)} \u003c/div\u003e \u003c/div\u003e ) } 接下来，尝试一下selector依赖atom 做一个筛选todo item的功能 定义两个新的state，分别是筛选后的列表数据、筛选值，放在store中 const filterState = atom({ key: \"filterState\", default: \"all\" }) const filteredListState = selector({ key: \"filteredListState\", get: ({ get }) =\u003e { const filter = get(filterState); const list = get(listDataState); switch (filter) { case 'all': return list case 'undos': return list.filter((item) =\u003e !item.isDone); default: return list; } }, }) 然后在todoList中map list用filteredListState替代原来的list，再增加修改过滤值的逻辑即可 function todoList(){ const [filter, setFilter] = useRecoilState(filterState); const filteredListData = useRecoilValue(filteredListState); {/* other code */} return ( \u003cdiv className=\"list\"\u003e {/* other code */} \u003cul\u003e {filteredListData.map((item, index) =\u003e { return ( \u003cli key={index + md5(item.label)}\u003e\u003cTodoItem itemdata={item} /\u003e\u003c/li\u003e ) })} \u003c/ul\u003e \u003cselect value={filter} onChange={({ target: { value } }) =\u003e setFilter(value)}\u003e \u003coption value=\"all\"\u003eAll\u003c/option\u003e \u003coption value=\"completed\"\u003eCompleted\u003c/option\u003e \u003coption value=\"undos\"\u003eUncompleted\u003c/option\u003e \u003c/select\u003e \u003c/div\u003e ) } 接下来再尝试一下selector获取异步数据的能力 把默认值放在mock中 // mocker/index.js const proxy = { 'GET /remotelistdata': {data: [ { id: 1, label: \"from remote planet\", visible: true, isDone: false }, { id: 2, label: \"sing from moon\", visible: true, isDone: false }, ]} } module.exports = proxy; 增加异步获取数据的selector const queryListDataState = selector({ key: \"queryListDataState\", get: async () =\u003e { const res = await axios.get('/remotelistdata'); console.log(res); return res.data.data; } }) 判断加载完成后，设置远程数据替换掉本地默认数据 const queryListData = useRecoilValueLoadable(queryListDataState); if(queryListData.state === \"hasValue\") { setListData(queryListD","date":"2020-05-25","objectID":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:1:5","tags":["react","recoil"],"title":"recoiljs 快速上手指南","uri":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["web"],"content":"评价 pros selector这种Derived State的设计，适合处理依赖性逻辑，方便快速开发 将state拆分为最小状态，并且可以随意分散管理，应用的模块分割可以进行得更加彻底 非常适合取代state层级很深的redux管理模块，由于状态细粒度，性能可以得到很好的优化，可以在应用内小范围使用与redux兼容 支持react concurrent模式 cons API太多了，不想上手 使用state需要引入定义的atom/selector以及use… API，复杂，不想上手 现在不支持ts btw recoil的实现原理是发布订阅的方式，许多概念像不像rxjs？atom、selector，还有官方给的waitAll，waitAny等等API 接下来和reto/mobx对比一下… 还想测试一下recoil的性能… 然后讨论一下recoil的实现原理… ","date":"2020-05-25","objectID":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:1:6","tags":["react","recoil"],"title":"recoiljs 快速上手指南","uri":"/myblog/recoiljs%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["后端"],"content":"have fun with nsq 🚀 ","date":"2020-04-06","objectID":"/myblog/nsq%E5%88%9D%E6%8E%A2/:0:0","tags":["nsq","MQ"],"title":"nsq初探","uri":"/myblog/nsq%E5%88%9D%E6%8E%A2/"},{"categories":["后端"],"content":"什么是nsq 推荐看看这篇文章，开发nsq的项目组对nsq的想法 我们是如何使用NSQ处理7500亿消息的 ","date":"2020-04-06","objectID":"/myblog/nsq%E5%88%9D%E6%8E%A2/:1:0","tags":["nsq","MQ"],"title":"nsq初探","uri":"/myblog/nsq%E5%88%9D%E6%8E%A2/"},{"categories":["后端"],"content":"消息队列 nsq是一种MQ（消息队列），常见的MQ还有比如RabbitMQ、Kafka等等 那什么是消息队列呢？ 消息队列其实就是将数据/请求存放入队列中，生产者在队列一头提供数据/请求，消费者在队列另一头消费数据/请求 消息队列原型\" 消息队列原型 为什么要用消息队列呢？ 我们将好处概括为解耦、异步和均流 解耦 多个系统之间数据往往有交互，这就导致了一个系统的崩溃会影响到其他系统，系统需求变更又会导致彼此接口的变更，可见系统的独立性大大下降；引入消息队列的一大好处是解耦了多系统，增加了可靠性 系统解耦的例子\" 系统解耦的例子 异步 异步实际是将后续操作延缓了，因为将数据放到了MQ中，不必等待其他系统的响应就直接返回；这样增加了系统的响应速度，但是导致了返回结果的不可靠性（因为后续可能会导致操作失败呀）；所以这里我们需要注意应用异步有一定的适用场景 异步快速响应\" 异步快速响应 均流 系统数据量在时间上分布一般是不均匀的，比如可能在白天下午时段有洪水期，而在其他时段数据流极小；通过应用MQ可以实现负载的均衡 负载均衡\" 负载均衡 ","date":"2020-04-06","objectID":"/myblog/nsq%E5%88%9D%E6%8E%A2/:1:1","tags":["nsq","MQ"],"title":"nsq初探","uri":"/myblog/nsq%E5%88%9D%E6%8E%A2/"},{"categories":["后端"],"content":"nsq组成模块 NSQ由3个进程组成： nsqd: 接收，维护队列和分发消息给客户端的daemon进程 nsqlookupd: 管理拓扑信息并提供最终一致性的发现服务 nsqadmin: 用于实时监控集群运行并提供管理命令的管理网站平台。 ","date":"2020-04-06","objectID":"/myblog/nsq%E5%88%9D%E6%8E%A2/:1:2","tags":["nsq","MQ"],"title":"nsq初探","uri":"/myblog/nsq%E5%88%9D%E6%8E%A2/"},{"categories":["后端"],"content":"nsq docker部署 docker pull nsqio/nsq docker run -d --name lookupd -p 4160:4160 -p 4161:4161 nsqio/nsq /nsqlookupd docker run -d --name nsqd -p 4150:4150 -p 4151:4151 nsqio/nsq /nsqd --broadcast-address=149.28.73.98 --lookupd-tcp-address=149.28.73.98:4160 docker run -d --name nsqadmin -p 4171:4171 nsqio/nsq /nsqadmin --lookupd-http-address=149.28.73.98:4161 部署完成后可以通过浏览器访问nsqadmin nsq nodes管理页面\" nsq nodes管理页面 ","date":"2020-04-06","objectID":"/myblog/nsq%E5%88%9D%E6%8E%A2/:1:3","tags":["nsq","MQ"],"title":"nsq初探","uri":"/myblog/nsq%E5%88%9D%E6%8E%A2/"},{"categories":["web"],"content":"记录React源码阅读的一些收获 always updating… ","date":"2020-04-05","objectID":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:0:0","tags":["react"],"title":"React源码阅读笔记","uri":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["web"],"content":"Flow and Rollup ","date":"2020-04-05","objectID":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:0","tags":["react"],"title":"React源码阅读笔记","uri":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["web"],"content":"flow flow是辅助JavaScript的静态类型检查工具，相对于TypeScript来说，不需要改写全部的功能模块 而且使用Flow只需要依赖于Babel的插件，具有极大的灵活性 怎么用？ # 安装flow npm install --save-dev flow-bin # package.json添加对应的script # init npm run flow init # babel安装依赖插件 npm install --save-dev babel-preset-flow # .babelrc添加flow的preset 配置好了Flow，只要在要使用的模块里@flow注解，然后增加想要的类型检查 /* @flow */ function add(x: number, y: number): number { return x + y } add(22, 11) 注意：Flow拥有上下文推断类型的能力 ","date":"2020-04-05","objectID":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:1","tags":["react"],"title":"React源码阅读笔记","uri":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["web"],"content":"rollup 打包工具 开发库用rollup 开发项目用webpack rollup主要优点是体积小 但是不支持热加载 ","date":"2020-04-05","objectID":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:2","tags":["react"],"title":"React源码阅读笔记","uri":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["web"],"content":"React源码目录结构 ├── build ------------------------------- 构建后的输出目录 ├── fixtures ---------------------------- React 开发的测试用例 ├── packages ---------------------------- 源码目录 │ ├── create-subscription ------------- 在组件里订阅额外数据的工具 │ ├── events -------------------------- 事件处理 │ ├── interaction-tracking ------------ 跟踪交互事件 │ ├── react --------------------------- 核心代码 │ ├── react-art ----------------------- 矢量图形库 │ ├── react-dom ----------------------- DOM 渲染相关 │ ├── react-is ------------------------ React 元素类型相关 │ ├── react-native-renderer ----------- react-native 渲染相关 │ ├── react-noop-renderer ------------- Fiber 测试相关 │ ├── react-reconciler ---------------- React 调制器 │ ├── react-scheduler ----------------- 规划 React 初始化，更新等等 │ ├── react-test-renderer ------------- 实验性的 React 渲染器 │ ├── shared -------------------------- 通用代码 │ ├── simple-cache-provider ----------- 为 React 应用提供缓存 │ ├── server -------------------------- 服务端渲染 │ ├── sfc ----------------------------- .vue 文件解析 │ ├── shared -------------------------- 整个项目通用代码 ├── scripts ----------------------------- 公共的lint，build，test和release等相关的文件 │ ├── eslint -------------------------- 语法规则和代码风格 │ ├── flow ---------------------------- Flow 类型声明 │ ├── git ----------------------------- git钩子的目录 │ ├── jest ---------------------------- JavaScript 测试目录 │ ├── release ------------------------- 自动发布新版本脚本 │ ├── rollup -------------------------- rollup 构建目录 ├── .babelrc ---------------------------- babel 配置文件 ├── .editorconfig ----------------------- 编辑器语法规范配置 ├── .eslintignore ----------------------- eslint 忽略配置 ├── .eslintrc --------------------------- eslint 配置文件 ├── .gitattributes ---------------------- 给 attributes 路径名的简单文本文件 ├── .gitignore -------------------------- git 忽略配置 ├── .mailmap ---------------------------- 邮件列表档案 ├── .nvmrc ------------------------------ nvm 配置文件 ├── .prettierrc.js ---------------------- prettierrc 配置文件 ├── .watchmanconfig --------------------- watchman 配置文件 ├── appveyor.yml ------------------------ GitHub 托管项目的自动化集成 ├── AUTHORS ----------------------------- 开发者列表档案 ├── CHANGELOG.md ------------------------ 更新日志 ├── CODE_OF_CONDUCT.md ------------------ Code of Conduct ├── CONTRIBUTING.md --------------------- Contributing to React ├── dangerfile.js ----------------------- 提高 Code Review 体验 ├── netlify.toml ------------------------ 持续集成静态网站 ├── package-lock.json ------------------- npm 加锁文件 ├── package.json ------------------------ 项目管理文件 ├── README.md --------------------------- 项目文档 ├── yarn.lock --------------------------- yarn 加锁文件 由于将react-dom单独提取出来了，所以react本身的核心代码只有几千行，先来看看咯 ","date":"2020-04-05","objectID":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:0","tags":["react"],"title":"React源码阅读笔记","uri":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["web"],"content":"react核心代码 ","date":"2020-04-05","objectID":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:0","tags":["react"],"title":"React源码阅读笔记","uri":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["web"],"content":"对外暴露的API react对外是一个Javascript对象，暴露了它的API，位置在packages/react/src/index.js export { Children, //处理props.children的方法 createRef, //新的ref用法 Component, //组件基类 PureComponent, //组件基类 createContext, //新的context用法 forwardRef, //ref传递 lazy, memo, useCallback, useContext, useEffect, useImperativeHandle, useDebugValue, useLayoutEffect, useMemo, useReducer, useRef, useState, useMutableSource, createMutableSource, Fragment, Profiler, StrictMode, Suspense, createElement, //创建element cloneElement, //克隆element isValidElement, //验证是否是react element version, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, createFactory, //创建某一类element useTransition, useDeferredValue, SuspenseList, unstable_withSuspenseConfig, block, DEPRECATED_useResponder, DEPRECATED_createResponder, unstable_createFundamental, unstable_createScope, } from './src/React'; 可以看到许多由于最近加了hooks多了不少use开头的API ","date":"2020-04-05","objectID":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:1","tags":["react"],"title":"React源码阅读笔记","uri":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["web"],"content":"Component和PureComponent function Component(props, context, updater) { this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue; } Component.prototype.isReactComponent = {}; // setState Component.prototype.setState = function(partialState, callback) { // partialState:产生下一个state的部分state // callback:update state以后的回调函数 invariant( typeof partialState === 'object' || typeof partialState === 'function' || partialState == null, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.', ); this.updater.enqueueSetState(this, partialState, callback, 'setState'); }; // forceUpdate Component.prototype.forceUpdate = function(callback) { this.updater.enqueueForceUpdate(this, callback, 'forceUpdate'); }; pureComponent继承了component的prototype，中间造了个dummyComponent（不知道有什么用） function PureComponent(props, context, updater) { this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue; } const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy()); pureComponentPrototype.constructor = PureComponent; Object.assign(pureComponentPrototype, Component.prototype); pureComponentPrototype.isPureReactComponent = true; 两者使用上有什么差别 可以看到源码的定义是几乎完全一样，但是根据渲染的代码可以知道pureComponent在某些情况下可以提升性能 通过浅比较（react定义的shallowEqual） if (ctor.prototype \u0026\u0026 ctor.prototype.isPureReactComponent) { return ( !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) ); } 所谓浅比较就是引用发生改变的时候会判定不同，否则相同 可以参考一下下面的例子👇 class BasicType extends React.PureComponent{ constructor() { super(); this.state = { isShow: false }; console.log('constructor BasicType'); } changeState = () =\u003e { this.setState({ isShow: true }) }; render() { // render will not be output after first render console.log('render'); return ( \u003cdiv\u003e \u003cbutton onClick={this.changeState}\u003e点击\u003c/button\u003e \u003cdiv\u003e{this.state.isShow.toString()}\u003c/div\u003e \u003c/div\u003e ); } } class ArrayType extends React.PureComponent{ constructor() { super(); this.state = { arr: [1,2,3] }; console.log('constructor ArrayType'); } changeState = () =\u003e { const tarr = this.state.arr; tarr.push(1); this.setState({ arr: tarr }) console.log(\"this.state:\",this.state.arr) }; render() { console.log('render'); return ( \u003cdiv\u003e \u003cbutton onClick={this.changeState}\u003e点击\u003c/button\u003e \u003cdiv\u003e{this.state.arr.toString()}\u003c/div\u003e \u003c/div\u003e ); } } const R = () =\u003e { return ( \u003cdiv\u003e \u003cBasicType /\u003e \u003cArrayType /\u003e \u003c/div\u003e ) } ReactDOM.render( \u003cR/\u003e, document.getElementById('root') ); 所以PureComponent适用场景是展示组件或者引用数据不发生改变的地方 比如注意下面这个例子👇 我们不希望每秒钟子组件Child也跟着渲染 class ABC extends React.Component { constructor(props){ super(props); this.state = { date : new Date() } } componentDidMount(){ setInterval(()=\u003e{ this.setState({ date:new Date() }) },1000) } render(){ return ( \u003cdiv\u003e \u003cChild seconds={1}/\u003e \u003cdiv\u003e{this.state.date.toString()}\u003c/div\u003e \u003c/div\u003e ) } } ","date":"2020-04-05","objectID":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:2","tags":["react"],"title":"React源码阅读笔记","uri":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["web"],"content":"memo 取的名字有点意思——备忘录，可能就是代表规模小的数据展示组件吧 react核心代码里只写了定义 export function memo\u003cProps\u003e( type: React$ElementType, compare?: (oldProps: Props, newProps: Props) =\u003e boolean, ) { if (__DEV__) { if (!isValidElementType(type)) { console.error( 'memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type, ); } } return { $$typeof: REACT_MEMO_TYPE, type, compare: compare === undefined ? null : compare, }; } 所以就是传入一个react element和一个props自定义比较函数，返回一个对象 使用起来就是这样👇 function Child({seconds}){ console.log('I am rendering'); return ( \u003cdiv\u003eI am update every {seconds} seconds\u003c/div\u003e ) }; function areEqual(prevProps, nextProps) { if(prevProps.seconds===nextProps.seconds){ return true }else { return false } } export default React.memo(Child,areEqual) 看上去就是一个针对函数组件的PureComponent呢 ","date":"2020-04-05","objectID":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:3","tags":["react"],"title":"React源码阅读笔记","uri":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["web"],"content":"createElement 传入type、config和children，return一个ReactElement function createElement(type, config, children) { // 这里是对config和children的一些处理 return ReactElement( type, key, ref, self, source, ReactCurrentOwner.current, props, ); } 可以看到传入config中的key和ref被保留了下来 我们看看ReactElement是什么？ ReactElement const ReactElement = function(type, key, ref, self, source, owner, props) { const element = { // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner, }; return element; }; type类型，用于判断如何创建节点 key和ref这些特殊信息 props新的属性内容 $$typeof用于确定是否属于ReactElement ","date":"2020-04-05","objectID":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:4","tags":["react"],"title":"React源码阅读笔记","uri":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["web"],"content":"Children 前面说到这里提供了几个处理children的API const Children = { map, forEach, count, toArray, only, }; 先看下比如map的使用 var NotesList = React.createClass({ render: function() { return ( \u003col\u003e { React.Children.map(this.props.children, function (child) { return \u003cli\u003e{child}\u003c/li\u003e; }) } \u003c/ol\u003e ); } }); React.render( \u003cNotesList\u003e \u003cspan\u003ehello\u003c/span\u003e \u003cspan\u003ehello\u003c/span\u003e \u003c/NotesList\u003e, document.body ); ","date":"2020-04-05","objectID":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:5","tags":["react"],"title":"React源码阅读笔记","uri":"/myblog/react%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"GroupCache源码阅读的一些笔记 同步到了repo ","date":"2020-04-04","objectID":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:0:0","tags":["cache","一致性哈希","singleflight"],"title":"Groupcache源码阅读笔记","uri":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"lru 总体而言实现方式为双向链表+map 主要逻辑如下： 添加一个新key/或者更新已有key，将key对应的element执行PushFront/MoveToFront操作，也就是放到链表最前，然后判断是否超过了最大容量，超过就删除链表最末element 查询一个key，同样执行MoveToFront操作 此外当key-element被删除的时候，源码显示可以执行OnEvicted操作，但是似乎在lru cache注册阶段没有写对这个回调函数的注入（???） 缺点的话：主要就是依赖的container/list是线程不安全的，不支持并行，效率有点低，外部需要维护一下同步的问题 ","date":"2020-04-04","objectID":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:0","tags":["cache","一致性哈希","singleflight"],"title":"Groupcache源码阅读笔记","uri":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"consistenthash 一致性哈希 实现方式就是根据理论来 主要逻辑如下： 为了hash ring上节点能尽可能平均分布，因此允许虚拟节点，为此传入replicas表示总节点数=实节点*replicas hash函数允许自定义，默认的hash函数为crc32，crc是一种追求速度不追求低碰撞率的hash算法，具体可以看wiki 对虚拟节点的处理通过加前置index再hash for i := 0; i \u003c m.replicas; i++ { hash := int(m.hash([]byte(strconv.Itoa(i) + key))) m.keys = append(m.keys, hash) m.hashMap[hash] = key } 放进去的keys为了接下来在get的时候找到最近，需要进行排序，源码直接根据hash的字母序排序 get某个key的时候就是寻找key对应的hash在hash ring上距离最近的节点，源码用的是sort.Search，一个sort依赖模块的二分查找方法 源码没有写对key的remove操作，难道要clear掉重新add吗 ","date":"2020-04-04","objectID":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:0","tags":["cache","一致性哈希","singleflight"],"title":"Groupcache源码阅读笔记","uri":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"singleflight 这个模块实现的功能可以说是groupcache的一大亮点，而且代码量极小 当get请求的key找不到的时候，并发的相同的get请求可能会击穿缓存 通过singleflight对并发相同key的get请求进行拦截，那么真正只会去get一个（无论是去peer还是怎样），其他就可以直接返回 结合代码看一下： type call struct { wg sync.WaitGroup val interface{} err error } type Group struct { mu sync.Mutex m map[string]*call } func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) { g.mu.Lock() if g.m == nil { g.m = make(map[string]*call) } if c, ok := g.m[key]; ok { g.mu.Unlock() c.wg.Wait() return c.val, c.err } c := new(call) c.wg.Add(1) g.m[key] = c g.mu.Unlock() c.val, c.err = fn() c.wg.Done() g.mu.Lock() delete(g.m, key) g.mu.Unlock() return c.val, c.err } 对Group的操作通过mutex锁保护起来 每一个key都有一个call，内部有wg锁来阻塞 当命中key的时候，wg wait，也就是被阻塞住直到执行阻塞的第一次get返回了值 如果没有命中key，那就是第一次get这个key，所以新建一个call，然后wg add 1，然后执行fn函数去取得值，最后wg done释放阻塞 记得用完要把这个key删掉哦 不然下次进来直接命中key而且无阻塞返回val了，导致错误 代码短小精悍，对并发的控制却是精妙绝伦！ ","date":"2020-04-04","objectID":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:0","tags":["cache","一致性哈希","singleflight"],"title":"Groupcache源码阅读笔记","uri":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"groupcachepb pb就是protobuf的简写，所以这就是一个提供通信的模块，利用protobuf做序列化和反序列化 里面有groupcache.pb.go和groupcache.proto两个文件，其实就是编写了proto文件然后利用protobuf生成go文件 message GetRequest { required string group = 1; required string key = 2; // not actually required/guaranteed to be UTF-8 } message GetResponse { optional bytes value = 1; optional double minute_qps = 2; } service GroupCache { rpc Get(GetRequest) returns (GetResponse) { }; } 具体去看proto文件，定义了request和response的一些字段，还定义了rpc通信接口 ","date":"2020-04-04","objectID":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:4:0","tags":["cache","一致性哈希","singleflight"],"title":"Groupcache源码阅读笔记","uri":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"byteview and sinks byteview模块封装了一个string与byte[] 的统一接口，也就是说用byteview提供的接口，可以屏蔽掉string与byte[] 的不同，使用时可以不用考虑是string还是byte[] 然后sinks模块在其基础上实现了几个sinks struct，相当于做了数据的储存，可以set；可以view；setproto方法是用来从protobuf的message中把数据sink下来 这里涉及到的代码重复度比较高，几个struct逻辑都是基本相同的，在此不赘述 ","date":"2020-04-04","objectID":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:5:0","tags":["cache","一致性哈希","singleflight"],"title":"Groupcache源码阅读笔记","uri":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"peers and http 这两个模块就完成了peer的分工和协作 先看peer模块，我们这里就不管nopeers的部分了（也没有什么东西），直接看peers type ProtoGetter interface { Get(ctx context.Context, in *pb.GetRequest, out *pb.GetResponse) error } type PeerPicker interface { PickPeer(key string) (peer ProtoGetter, ok bool) } 定义了两个个接口，关注一下PeerPicker接口，用于在给定key的时候返回处理这个key的peer，类型是protogetter，也就是第一个interface 那么相对应的pickpeer注册如下（可以看到只能注入一次） var ( portPicker func(groupName string) PeerPicker ) func RegisterPeerPicker(fn func() PeerPicker) { if portPicker != nil { panic(\"RegisterPeerPicker called more than once\") } portPicker = func(_ string) PeerPicker { return fn() } } 注册完如何找到key对应peer的函数，在groupcache调用getPeers如下的时候可以查找到peer func getPeers(groupName string) PeerPicker { if portPicker == nil { return NoPeers{} } pk := portPicker(groupName) if pk == nil { pk = NoPeers{} } return pk } 然后看相对比较复杂的http模块 type HTTPPool struct { Context func(*http.Request) context.Context Transport func(context.Context) http.RoundTripper // this peer's base URL, e.g. \"https://example.net:8000\" self string // opts specifies the options. opts HTTPPoolOptions mu sync.Mutex // guards peers and httpGetters peers *consistenthash.Map httpGetters map[string]*httpGetter // keyed by e.g. \"http://10.0.0.2:8008\" } type HTTPPoolOptions struct { BasePath string Replicas int HashFn consistenthash.Hash } 有上述的options参与定义httppool，所以用到了consistent hash，也就是存放peers hash对应的数据结构，所以会将peers加入到consistent hash中 type httpGetter struct { transport func(context.Context) http.RoundTripper baseURL string } // ... other code func (p *HTTPPool) Set(peers ...string) { p.mu.Lock() defer p.mu.Unlock() p.peers = consistenthash.New(p.opts.Replicas, p.opts.HashFn) p.peers.Add(peers...) p.httpGetters = make(map[string]*httpGetter, len(peers)) for _, peer := range peers { p.httpGetters[peer] = \u0026httpGetter{transport: p.Transport, baseURL: peer + p.opts.BasePath} } } 我们关注到httpGetter是实际处理通信的，源码这里的transport是一个可自定义的通信函数，默认使用 http.DefaultTransport 那么httpGetter是怎样的呢？其实就是通过protobuf发送get请求 func (h *httpGetter) Get(ctx context.Context, in *pb.GetRequest, out *pb.GetResponse) error { u := fmt.Sprintf( \"%v%v/%v\", h.baseURL, url.QueryEscape(in.GetGroup()), url.QueryEscape(in.GetKey()), ) req, err := http.NewRequest(\"GET\", u, nil) if err != nil { return err } req = req.WithContext(ctx) tr := http.DefaultTransport if h.transport != nil { tr = h.transport(ctx) } res, err := tr.RoundTrip(req) if err != nil { return err } defer res.Body.Close() if res.StatusCode != http.StatusOK { return fmt.Errorf(\"server returned: %v\", res.Status) } b := bufferPool.Get().(*bytes.Buffer) b.Reset() defer bufferPool.Put(b) _, err = io.Copy(b, res.Body) if err != nil { return fmt.Errorf(\"reading response body: %v\", err) } err = proto.Unmarshal(b.Bytes(), out) if err != nil { return fmt.Errorf(\"decoding response body: %v\", err) } return nil } 那peer作为客户端发送get请求，作为服务端还要响应get请求吧，所以又有如下的handle处理 func (p *HTTPPool) ServeHTTP(w http.ResponseWriter, r *http.Request) { // Parse request. if !strings.HasPrefix(r.URL.Path, p.opts.BasePath) { panic(\"HTTPPool serving unexpected path: \" + r.URL.Path) } parts := strings.SplitN(r.URL.Path[len(p.opts.BasePath):], \"/\", 2) if len(parts) != 2 { http.Error(w, \"bad request\", http.StatusBadRequest) return } groupName := parts[0] key := parts[1] // Fetch the value for this group/key. group := GetGroup(groupName) if group == nil { http.Error(w, \"no such group: \"+groupName, http.StatusNotFound) return } var ctx context.Context if p.Context != nil { ctx = p.Context(r) } else { ctx = r.Context() } group.Stats.ServerRequests.Add(1) var value []byte err := group.Get(ctx, key, AllocatingByteSliceSink(\u0026value)) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } // Write the value to the response body as a proto message. body, err := proto.Marshal(\u0026pb.GetResponse{Value: value}) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } w.Header().Set(\"Content-Type\", \"application/x-protobuf\") w.Write(body) } ","date":"2020-04-04","objectID":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:6:0","tags":["cache","一致性哈希","singleflight"],"title":"Groupcache源码阅读笔记","uri":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["golang"],"content":"groupcache 接下来是控制中心 groupcache.go 抛开一切次要代码 先看一下group结构 type Group struct { name string getter Getter peersOnce sync.Once peers PeerPicker cacheBytes int64 mainCache cache hotCache cache loadGroup flightGroup _ int32 Stats Stats } 源码其实注解得相当清楚： name对应group标识符 getter是获取val的处理函数 peers是peer groups的集合，实现了peerpicker接口 cacheBytes 决定了cache的大小 mainCache是当前group的缓存区 hotCache是从其他group查询后迁移过来的缓存 loadGroup避免缓冲击穿 Stats维护了缓存的状态数据，包括查询热点等等 主要逻辑是酱： 初始化peers 先在本地的mainCache和hotCache查询，找到就返回 找不到的话去peers中查询，用哪一个peer通过peerPicker，内部由consistenthash实现，然后迁移到hotcache 如果peers还没有，那就去再下一层的数据库或者文件查找（数据源的定义和操作都是自定义的） 中间为了避免缓存击穿，使用了singleflight cache每次操作key后都会根据lru更新 ","date":"2020-04-04","objectID":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:7:0","tags":["cache","一致性哈希","singleflight"],"title":"Groupcache源码阅读笔记","uri":"/myblog/groupcache%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["web"],"content":"记录迁移个人博客到Hugo的过程 ","date":"2020-03-30","objectID":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:0:0","tags":["Docker","Hugo","Webhooks"],"title":"Hugo+Docker+Webhooks最佳实践","uri":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["web"],"content":"写在前面 在这之前，我的技术博客经历过wordpress、hexo、typecho 为什么选择Hugo build速度快 符合个人写作习惯（typora locally） golang大法好 开始的想法是单纯部署在Github Pages上，但是github响应速度太慢 于是决定采用github作为仓库，实际部署在自己的阿里云服务器上，用Docker+Webhooks的形式实现高效管理 ","date":"2020-03-30","objectID":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:1:0","tags":["Docker","Hugo","Webhooks"],"title":"Hugo+Docker+Webhooks最佳实践","uri":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["web"],"content":"Docker For Static ","date":"2020-03-30","objectID":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:0","tags":["Docker","Hugo","Webhooks"],"title":"Hugo+Docker+Webhooks最佳实践","uri":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["web"],"content":"docker docker是隔离项目和宿主机的最佳解决方案，采用docker可以避免宿主机环境和项目环境的互相影响，同样有助于项目的版本迭代 ","date":"2020-03-30","objectID":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:1","tags":["Docker","Hugo","Webhooks"],"title":"Hugo+Docker+Webhooks最佳实践","uri":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["web"],"content":"方案 hugo build生成静态网页文件，存放在public文件夹中 通过git版本管理，线上仓库用github 阿里云服务器构建一个nginx的docker，将usr/share/nginx/html挂载到宿主机 ","date":"2020-03-30","objectID":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:2","tags":["Docker","Hugo","Webhooks"],"title":"Hugo+Docker+Webhooks最佳实践","uri":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["web"],"content":"bash code # 查找nginx docker源 docker search nginx # 下载想要的nginx docker install nginx:(tag) # 可以通过docker images查看是否下载完成 docker images # 运行docker docker run -dt \\ --restart=always \\ --name hugoblog \\ -p 8010:80 \\ -v ~/hugoblog/html:/usr/share/nginx/html \\ -d nginx ","date":"2020-03-30","objectID":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:3","tags":["Docker","Hugo","Webhooks"],"title":"Hugo+Docker+Webhooks最佳实践","uri":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["web"],"content":"Webhooks ","date":"2020-03-30","objectID":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:3:0","tags":["Docker","Hugo","Webhooks"],"title":"Hugo+Docker+Webhooks最佳实践","uri":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["web"],"content":"webhooks github被微软收购以后推出的免费功能 当用户注册好webhooks后，github会在repo发生变动后向用户注册的URL发送一个post请求 send me everything 的选项将会涉及几十种事件，可参见webhooks的文档，这里我只选择了push事件需要通知 payload URL 中需要填写可接受post请求的网络地址 Content type 是post请求的body格式，这里我选择了application/json Secret 是自行设定的一个密钥，收到post请求后在服务器端可以通过密钥对packet进行验证 ","date":"2020-03-30","objectID":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:3:1","tags":["Docker","Hugo","Webhooks"],"title":"Hugo+Docker+Webhooks最佳实践","uri":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["web"],"content":"server handler 接下来就是服务端对post请求响应处理的逻辑 我用的是Expressjs，是一个Node框架，主要业务逻辑如下（偷懒没有写检验） // hugoblog webhook // 偷懒不写校验了 app.post('/hugoblog', (req, res) =\u003e { console.log(req.body); const eventName = req.get('X-GitHub-Event') const sign = req.get('X-Hub-Signature') const delivery = req.get('X-GitHub-Delivery') const refHead = req.body.ref console.log(\"Receive a event: \", eventName); console.log('sign:', sign) console.log('delivery:', delivery) console.log('refHead:', refHead, typeof(refHead),refHead === 'refs/heads/master') if(refHead === 'refs/heads/master') { const shell = 'app/bash/hugoblog.sh' setTimeout(() =\u003e { console.log('new thread execute shell', shell) exec(shell, (err,stdout,stderr) =\u003e { if (stdout) { console.log('stdout out \u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e') console.log(stdout) console.log('stdout over \u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e') } err \u0026\u0026 console.log('hasErr: ', err) stderr \u0026\u0026 console.log('stderr: ', stderr) }) }, 500) } res.send(\"ok\"); }) 当接收到post请求后，判断是否为master分支的请求，然后执行准备好的bash脚本 bash脚本内容如下 WEB_PATH='/root/hugoblog/html' echo \"Start deployment\" cd $WEB_PATH echo \"pulling source code...\" git pull origin master echo \"restart docker...\" docker restart hugoblog echo \"Finished.\" 注意 记得要重启承载静态网页文件的nginx docker哦 ","date":"2020-03-30","objectID":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:3:2","tags":["Docker","Hugo","Webhooks"],"title":"Hugo+Docker+Webhooks最佳实践","uri":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["web"],"content":"让Blog更新只需要一行命令 bash，让你的生活更美好😄 # filename: fire.sh # path: hugo站点根目录下 echo \"ready to fire...\" echo \"hugo build\" hugo echo \"cd public dir\" cd public echo \"git add\" git add . echo \"git commit\" git commit -m \"hugo modify - auto commit\" echo \"git push\" git push origin master echo \"fire finished\" 写好文章只需要 ./fire.sh 即可 ","date":"2020-03-30","objectID":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:4:0","tags":["Docker","Hugo","Webhooks"],"title":"Hugo+Docker+Webhooks最佳实践","uri":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["web"],"content":"Possible Error \u0026 Solution req.body没有data 主要是expressjs 4.0以后的版本将bodyparser模块功能独立了出来，需要自行添加中间件 // for json parser app.use(bodyParser.json()) // for x-www-form-urlencoded parser app.use(bodyParser.urlencoded({extended:true})); // 根据需要使用这两个中间件即可 bash脚本执行无效 起初我将响应webhook的expressjs同样做成了一个docker 这就导致执行bash是在容器内执行的，对宿主机没有任何影响 解决方案包括执行ssh远程命令、将响应webhook的框架直接架设在宿主机中、docker之间建立关联等等 ","date":"2020-03-30","objectID":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:5:0","tags":["Docker","Hugo","Webhooks"],"title":"Hugo+Docker+Webhooks最佳实践","uri":"/myblog/hugo-docker-webhooks%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["算法","大学课程"],"content":"适用于所有情况完全已知的游戏，并且是零和游戏。 零和游戏（Zero-sum Game）：意思就是你死我活，一方的胜利代表另一方的失败，比如，象棋，五子棋等。 完全信息（Perfect Information）：玩家知道之前所有的步骤。象棋就是完全信息，因为玩家是交替着落子，且之前的步骤都能在棋盘上体现，但是石头剪子布就不是。 这样的游戏可以用树状图表示：MAX表示自己，MIN表示对手；Utility是对着一种情况给出的分数（对自己而言越高越好） minmax\" minmax 那么自己希望最大化这一utility，对手希望最小化这一utility，所以可以通过结果反推某一步应该采取的选择。 step1\" step1 step2\" step2 step3\" step3 step4\" step4 由于情况数太多需要采取剪枝算法（Alpha-Beta）来减少运算量： 每个MAX结点设置一个目前已知下界alpha，每个MIN节点设置一个目前已知上界beta。当计算一个MIN结点时，如果它的beta值小于等于其父结点的alpha值，则可以立即停止此结点的计算（alpha剪枝）；当计算一个MAX结点时，如果它的alpha结点大于等于其父结点的beta值，也可以立即停止此结点的计算（beta剪枝） ","date":"2020-03-10","objectID":"/myblog/min-max%E7%AE%97%E6%B3%95%E5%8F%8Aalpha-beta%E5%89%AA%E6%9E%9D/:0:0","tags":["min-max","alpha-beta"],"title":"Min-Max算法及Alpha-Beta剪枝","uri":"/myblog/min-max%E7%AE%97%E6%B3%95%E5%8F%8Aalpha-beta%E5%89%AA%E6%9E%9D/"},{"categories":["算法"],"content":"记录一下很早就学过的并查集 最简洁而优雅的数据结构之一 主要用于解决一些元素分组的问题 ","date":"2020-02-07","objectID":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/:0:0","tags":["并查集"],"title":"并查集算法概念及实现","uri":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"核心思想 通过一维数组，index表示当前元素编号，value记录当前元素的上级元素，通过递归查找到关系网的根元素 这里要注意的是，为了避免查找效率低下，每次在查找根元素的时候进行路径压缩，也就是将路径上的元素的上级元素全部更改为根元素，这样减少了递归层级 ","date":"2020-02-07","objectID":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/:1:0","tags":["并查集"],"title":"并查集算法概念及实现","uri":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"数组记录元素关系 开始的时候key=value表示每个元素的爸爸是自己本身 relationrelation \" relation 然后比如2和3从属于1 那么就会有如下关系arr[2] = 1以及arr[3] = 1 relation2relation2 \" relation2 ","date":"2020-02-07","objectID":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/:1:1","tags":["并查集"],"title":"并查集算法概念及实现","uri":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"路径压缩 并查集的数据储存模式可能会导致从属链过长 而导致查询效率低下 routeroute \" route 比如上面的图在查询2的根节点的过程中 完全可以将这条路径上的所有节点直接指向4 这样就优化了数据结构 (换个角度讲就是减少了树的深度) ","date":"2020-02-07","objectID":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/:1:2","tags":["并查集"],"title":"并查集算法概念及实现","uri":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"实现代码 将并查集Disjoint Set Union写成一个单独的class方便调用 class DSU { public int parent[]; public DSU(int n) { this.parent = new int[n]; for(int i=0;i\u003cn;i++) parent[i] = i; } public int find(int x) { if(x!=parent[x]) parent[x] = find(parent[x]); return parent[x]; } public void join(int x, int y) { parent[find(x)] = find(y); } public void print() { for(int i=0;i\u003cparent.length;i++) { System.out.println(i+\": \"+parent[i]); } } } 这里对int find(int x)简单做一下解释 x表示待查找的元素 假如它并不是根元素 则调用find(parent[x])递归找到根元素 同时将根元素赋值给parent[x](这样就实现了路径的压缩) 返回的当然是parent[x] 因为只有它是在被更新的 ","date":"2020-02-07","objectID":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/:2:0","tags":["并查集"],"title":"并查集算法概念及实现","uri":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"LeetCode练习 上手练几道题巩固知识 ","date":"2020-02-07","objectID":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/:3:0","tags":["并查集"],"title":"并查集算法概念及实现","uri":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"#959 由斜杠划分区域 题目 在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\\ 或空格构成。这些字符会将方块划分为一些共边的区域。 （请注意，反斜杠字符是转义的，因此 \\ 用 “\\” 表示。） 返回区域的数目。 class Solution { public int regionsBySlashes(String[] grid) { int N = grid.length; DSU dsu = new DSU(4*N*N); for (int i=0;i\u003cN;i++) { for (int j=0;j\u003cN;j++) { char ch = grid[i].charAt(j); int base = (i*N + j)*4; // join in a cell if(ch == ' ') { dsu.join(base,base+1); dsu.join(base, base+2); dsu.join(base, base+3); } else if (ch == '/') { dsu.join(base,base+3); dsu.join(base+1,base+2); } else if (ch == '\\\\') { dsu.join(base,base+1); dsu.join(base+2,base+3); } else { System.out.println(\"input error!\"); return 0; } // join with other cells if(i \u003e 0) { dsu.join(base, base-4*N+2); } if(j \u003e 0) { dsu.join(base+3, base-4+1); } } } // get res int res = 0; for (int i = 0; i \u003c 4 * N * N; i++) { if (dsu.find(i) == i) res++; } return res; } } ","date":"2020-02-07","objectID":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/:3:1","tags":["并查集"],"title":"并查集算法概念及实现","uri":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"#990 等式方程的可满足性 题目 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：“a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 示例 1 输入：[“a==b”,“b!=a”] 输出：false 解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。 示例 2 输出：[“b==a”,“a==b”] 输入：true 解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。 示例 3 输入：[“a==b”,“b==c”,“a==c”] 输出：true 示例 4 输入：[“a==b”,“b!=c”,“c==a”] 输出：false 示例 5 输入：[“c==c”,“b==d”,“x!=z”] 输出：true 提示 1 \u003c= equations.length \u003c= 500 equations[i].length == 4 equations[i][0] 和 equations[i][3] 是小写字母 equations[i][1] 要么是 =，要么是 ! equations[i][2] 是 = class Solution { public boolean equationsPossible(String[] equations) { DSU dsu = new DSU(26); for (String equation : equations) { if(equation.charAt(1) == '=') { int x = equation.charAt(0) - 'a'; int y = equation.charAt(3) - 'a'; dsu.join(x, y); } } for (String equation : equations) { if(equation.charAt(1) == '!') { int x = equation.charAt(0) - 'a'; int y = equation.charAt(3) - 'a'; if(dsu.find(x) == dsu.find(y)) return false; } } return true; } } ","date":"2020-02-07","objectID":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/:3:2","tags":["并查集"],"title":"并查集算法概念及实现","uri":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"#1202 交换字符串中的元素 题目 给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始） 你可以任意多次交换在 pairs 中任意一对索引处的字符。 返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。 示例 1 输入：s = “dcab”, pairs = [[0,3],[1,2]] 输出：“bacd” 解释： 交换 s[0] 和 s[3], s = “bcad” 交换 s[1] 和 s[2], s = “bacd” 示例 2 输入：s = “dcab”, pairs = [[0,3],[1,2],[0,2]] 输出：“abcd” 解释： 交换 s[0] 和 s[3], s = “bcad” 交换 s[0] 和 s[2], s = “acbd” 交换 s[1] 和 s[2], s = “abcd” 示例 3 输入：s = “cba”, pairs = [[0,1],[1,2]] 输出：“abc” 解释： 交换 s[0] 和 s[1], s = “bca” 交换 s[1] 和 s[2], s = “bac” 交换 s[0] 和 s[1], s = “abc” 提示 1 \u003c= s.length \u003c= 10^5 0 \u003c= pairs.length \u003c= 10^5 0 \u003c= pairs[i][0], pairs[i][1] \u003c s.length s 中只含有小写英文字母 import java.util.*; public class SwapString { public static void main(String[] args) { Scanner in = new Scanner(System.in); SwapString a = new SwapString(); String s = in.nextLine(); int n = in.nextInt(); List\u003cList\u003cInteger\u003e\u003e pairs = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c n; i++) { ArrayList\u003cInteger\u003e pair = new ArrayList\u003c\u003e(); pair.add(in.nextInt()); pair.add(in.nextInt()); pairs.add(pair); } String res = a.smallestStringWithSwaps(s, pairs); System.out.println(\"res: \" + res); } public String smallestStringWithSwaps(String s, List\u003cList\u003cInteger\u003e\u003e pairs) { int len = s.length(); DSU dsu = new DSU(len); for (List\u003cInteger\u003e pair : pairs) { int x = pair.get(0); int y = pair.get(1); dsu.join(x, y); } // System.out.println(dsu); // force union int temp; HashSet\u003cInteger\u003e hs = new HashSet\u003c\u003e(); for (int i = 0; i \u003c len; i++) { temp = dsu.find(i); hs.add(temp); } StringBuilder strb = new StringBuilder(s); for (Integer item : hs) { System.out.println(\"sort item: \" + item); // collect item List\u003cCharacter\u003e ls = new ArrayList\u003c\u003e(); List\u003cInteger\u003e pos = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c len; i++) { if (dsu.parent[i] == item) { ls.add(s.charAt(i)); pos.add(i); } } // sort Collections.sort(ls, Comparator.comparingInt(Character::charValue)); System.out.println(ls); for (int i=0;i\u003cls.size();i++) { strb.setCharAt(pos.get(i), ls.get(i)); } } return strb.toString(); } } ","date":"2020-02-07","objectID":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/:3:3","tags":["并查集"],"title":"并查集算法概念及实现","uri":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["算法"],"content":"#1319 连通网络的操作次数 题目 用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b 网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机 给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 示例 1 输入：n = 4, connections = [[0,1],[0,2],[1,2]] 输出：1 解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。 示例 2 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] 输出：2 示例 3 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] 输出：-1 解释：线缆数量不足。 示例 4 输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]] 输出：0 提示 1 \u003c= n \u003c= 10^5 1 \u003c= connections.length \u003c= min(n*(n-1)/2, 10^5) connections[i].length == 2 0 \u003c= connections[i][0], connections[i][1] \u003c n connections[i][0] != connections[i][1] 没有重复的连接。 两台计算机不会通过多条线缆连接。 class Solution { public int makeConnected(int n, int[][] connections) { int len = connections.length; if(len+1 \u003c n) return -1; DSU dsu = new DSU(n); for(int i=0;i\u003clen;i++) { dsu.join(connections[i][0], connections[i][1]); } // dsu.print(); int ans = 0; for(int i=0;i\u003cn;i++) { if(i == dsu.find(i)) ans++; } // System.out.println(\"ans: \"+ans); return ans-1; } } ","date":"2020-02-07","objectID":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/:3:4","tags":["并查集"],"title":"并查集算法概念及实现","uri":"/myblog/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"categories":["web"],"content":"记录三小时搭建ownCloud云盘全过程🆒 话不多说, 先放一张成功的登录界面图👌 ","date":"2020-01-29","objectID":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/:0:0","tags":["owncloud","云盘"],"title":"ownCloud+mysql+docker搭建个人云盘","uri":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/"},{"categories":["web"],"content":"step 1: 选择一个适合的开源云盘 这里有很多选择 比如老牌劲旅ownCloud, 分裂继任者nextCloud或者是国产招牌seaFile, 都在开源云盘市场上占有一席之地 这里我主要参考了v2ex还有知乎网友的一些评论, 结合我自身的设备情况和维护代价选择了ownCloud 两个字——省心! ","date":"2020-01-29","objectID":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/:1:0","tags":["owncloud","云盘"],"title":"ownCloud+mysql+docker搭建个人云盘","uri":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/"},{"categories":["web"],"content":"step 2: 选择安装方式 首先去看一下ownCloud的官方文档, 主要是提供了以下几种安装方式: Installation with docker Manual Installation Manual Installation的话其实就是完整走一遍流程: Install ownCloud、Configure WebServer、Set Relationship…十分麻烦 我个人一直推崇使用docker进行项目的管理, 一方面docker中的配置不会影响到宿主机的环境配置, 另一方面docker中运行便于维护管理, 而且因为docker相当于梳理了一遍流程所以可以重复使用(因此就可以直接拿别人的docker配置单用啦🆒) 这里需要强调的一点是, ownCloud官方提供了docker包含了server和apache+php, 所以我就不舍近求远了直接用官方的docker image (如果有其他需要可以去docker hub搜索其他docker image) ownCloud docker允许使用内部自带的sqlite, 但是毕竟针对小文件还马马虎虎, 大文件就完犊子 所以我们还是需要一个mysql/mariadb(当然用postgresql也可以), 既然需要两个docker而且服务于同一目标——我们的个人云盘, 所以我直接采用docker-compose的方式 version:'2'services:owncloud:image:owncloudlinks:- mysql:mysqlvolumes:- \"/data/db/owncloud:/var/www/html/data\"ports:- \u003cwebport\u003e:80mysql:image:mysqlvolumes:- \"/data/db/mysql:/var/lib/mysql\"ports:- \u003cport\u003e:3306environment:MYSQL_ROOT_PASSWORD:\"\u003cpassword\u003e\"MYSQL_DATABASE:ownCloud ","date":"2020-01-29","objectID":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/:2:0","tags":["owncloud","云盘"],"title":"ownCloud+mysql+docker搭建个人云盘","uri":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/"},{"categories":["web"],"content":"step 3: 配置Nginx 我的阿里云机器所有项目都跑在各自的docker上, 然后对外端口有宿主机的Nginx同一映射管理, 所以我在/etc/nginx/conf.d目录下新建了一个针对ownCloud的代理转发conf: server { listen 80; server_name cloud.joyinn.top; proxy_set_header X-Forwarded-For $remote_addr; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; add_header Cache-Control \"no-cache\"; proxy_pass http://127.0.0.1:8001; limit_rate 256m; client_max_body_size 0; } } 这里需要注意的是两点, 一个是二级域名记得去域名解析那里配置好, 另一个是注意要取消Nginx的带宽大小限制, 否则ownCloud稍微大一点的文件就没有办法上传成功了 ","date":"2020-01-29","objectID":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/:3:0","tags":["owncloud","云盘"],"title":"ownCloud+mysql+docker搭建个人云盘","uri":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/"},{"categories":["web"],"content":"step 4: 配置ownCloud 进入配置好的webServer网址, 第一次访问会需要填写ownCloud的基本配置, 包括管理员账户名和密码, 以及数据库的相关配置 这里只需要对照在docker-compose.yml文件里配置的信息填写即可, localhost这一项应该填写mysql ","date":"2020-01-29","objectID":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/:4:0","tags":["owncloud","云盘"],"title":"ownCloud+mysql+docker搭建个人云盘","uri":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/"},{"categories":["web"],"content":"step 5: php版本过低 与 mysql8 的兼容性问题 这里我遇到了一个大坑, 花了很多时间才解决: “Error while trying to create admin user: Failed to connect to the database: An exception occured in driver: SQLSTATE[HY000] [2054] The server requested authentication method unknown to the client \" 搜索了谷歌, 看了许多帖子有了点头绪 遇到的问题就是ownCloud docker中的web目前使用的php版本比较低, 还没有兼容mysql8.0以上的全部特性, 比如mysql8.0以上使用的用户密码机制不同于原来, 因此导致这里访问的错误 摸索了以下, 得到以下的解决方案: 进入到mysql的container中, 增加 my.cnf 中一句配置: default_authentication_plugin=mysql_native_password 进入mysql, 执行以下命令: ALTER USER ‘root’@'%' IDENTIFIED WITH mysql_native_password BY ‘password’; 重启mysql的container ","date":"2020-01-29","objectID":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/:5:0","tags":["owncloud","云盘"],"title":"ownCloud+mysql+docker搭建个人云盘","uri":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/"},{"categories":["web"],"content":"step 6: 愉快的玩耍ownCloud吧 ","date":"2020-01-29","objectID":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/:6:0","tags":["owncloud","云盘"],"title":"ownCloud+mysql+docker搭建个人云盘","uri":"/myblog/owncloud-mysql-docker%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%9B%98/"},{"categories":["算法"],"content":"actor概念 Actor模型是处理并行计算的概念模型。模型中一个Actor是一个基本的计算单元。它接受消息然后基于接到的消息做一些计算。和面向对象编程有些类似，一个对象被调用（接收到一个消息），基于调用方法（接受到的一个消息）做处理。区别是actor之间是完全隔离的，不共用内存区域。actor的私有状态不会被另外一个actor直接改变。 在actor模型中，actor是唯一组成部分，actor带有地址以便互相发送消息。 actor按次序处理消息，比如你发送三个消息给一个actor，它们不会被并发处理。如果你想让这三个消息得到并发处理，你需要创建3个actor，然后分别发送给它们。接受到的异步消息存在于actor内部的一个队列中，我们可以把它形象化的叫做邮箱。 简单来说，Actor通过消息传递的方式与外界通信，而且消息传递是异步的。每个Actor都有一个邮箱，邮箱接收并缓存其他Actor发过来的消息，通过邮箱队列mail queue来处理消息。Actor一次只能同步处理一个消息，处理消息过程中，除了可以接收消息外不能做任何其他操作。 每个Actor是完全独立的，可以同时执行他们的操作。每个Actor是一个计算实体，映射接收到的消息并执行以下动作： 发送有限个消息给其他Actor 创建有限个新的Actor 为下一个接收的消息指定行为 这三个动作没有固定的顺序，可以并发地执行，Actor会根据接收到的消息进行不同的处理。 ","date":"2019-12-22","objectID":"/myblog/actor%E6%A8%A1%E5%9E%8B/:1:0","tags":["actor","并行"],"title":"Actor模型","uri":"/myblog/actor%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"进程间通信 把通信的线程可以想象成两个无法直接说话而必须通过邮件交流的人，双方要交流就要发送邮件。发送方邮件一旦发出就不能修改任何内容，而且是没有办法收回修改后再发的，这也就是消息一旦发出就不可改变。对于接收方而言，想什么时候看邮件就什么时候看，而且不需要监听，这就叫异步。接收方看了发送方的邮件可以回复也可以撒都不做。只是回复邮件一旦发出也同样是不能收回修改的，也就是不可变性两端都是一样的。同样，发送方针对回复邮件，也是想什么时候看就什么时候看。两端同样都是异步的。这种通信模型就是Actor想要的模型，可以发现这种通信方式其实依赖一套邮件系统或叫做消息管理系统。进程内部要有一套这样的系统，给每个线程一个独立的收发消息的管道，并且都是异步的。 ","date":"2019-12-22","objectID":"/myblog/actor%E6%A8%A1%E5%9E%8B/:2:0","tags":["actor","并行"],"title":"Actor模型","uri":"/myblog/actor%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"并发性 并发导致最大的问题是对共享数据的操作，面对并发问题时多采用锁去保证共享数据的一致性，但同样也会带来一系列的副作用，比如要去考虑锁的粒度（对方法、程序块等）、锁的形式（读锁、写锁等）等问题。 传统的并发编程的方式大多使用锁机制，相信大多数都是悲观锁，这几乎可以断定会出现两个非常明显的问题：随着项目体量增大，业务愈加复杂，不可避免地会大量的使用锁，然而锁的机制其实是很低效的。即使大量依赖锁解决了项目中资源竞争的情况，但由于没有一个规范的编程模式，最后系统的稳定性肯定会出问题，最根本的原因是没有把系统的任务调度抽象出来，由于任务调度和业务逻辑耦合在一起，很难做一个很高层的抽象以保证任务调度有序性。 Actor模型为并发而生，是为解决高并发的一种编程思路。使用并发编程时需要特别关注锁与内存原子性等一系列的线程问题，Actor模型内部的状态由自身维护，也就是说Actor内部数据只能由它自己通过消息传递来进行状态修改，所以使用Actor模型可以很好地避免这些问题。 ","date":"2019-12-22","objectID":"/myblog/actor%E6%A8%A1%E5%9E%8B/:3:0","tags":["actor","并行"],"title":"Actor模型","uri":"/myblog/actor%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"实例-买票场景 将计数器场景中基于线程的实现替换为Actor，当然Actor也要在线程中运行，但Actor只在有事情可做（没有消息要处理）的时候才会使用线程。 在计数器场景中，请求者代表CutomerActor，计数器数量由TicketsActor来维护并持有当前计数器的状态。CustomerActor和TicketsActor在空闲idle或没有事情做的时候都不会持有线程。 在初始购买操作时CustomerActor需要发送一个消息给TicketsActor，消息中包含了要购买的数量。当TicketsActor接收到消息时会校验购买数量是否超过库存数量，若合法则递减数量。此时TicketsActor会发送一条消息给CutomerActor表明订单被成功接受。若购买数量超过库存数量TicketsActor也会发送给CustomerActor一条消息，表明订单被拒绝。 可划分两个阶段的行为检查和递减操作，也可以通过同步操作序列来完成。但是基于Actor的实现不仅在每个Actor中提供了自然的操作同步，还能避免大量的线程积压，防止线程等待轮到它们执行同步代码区域。明显会降低系统资源的占用。 Actor模型本身确保处理是按照同步的方式执行的。TicketsActor会处理其收件箱中的每条消息，注意这里没有复杂的线程或锁，只是一个多线程的处理过程，但Actor系统会管理线程的使用和分配。 ","date":"2019-12-22","objectID":"/myblog/actor%E6%A8%A1%E5%9E%8B/:4:0","tags":["actor","并行"],"title":"Actor模型","uri":"/myblog/actor%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"实例-寻找素数 ","date":"2019-12-22","objectID":"/myblog/actor%E6%A8%A1%E5%9E%8B/:5:0","tags":["actor","并行"],"title":"Actor模型","uri":"/myblog/actor%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"传统锁方式 ","date":"2019-12-22","objectID":"/myblog/actor%E6%A8%A1%E5%9E%8B/:5:1","tags":["actor","并行"],"title":"Actor模型","uri":"/myblog/actor%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"Actor方式 ","date":"2019-12-22","objectID":"/myblog/actor%E6%A8%A1%E5%9E%8B/:5:2","tags":["actor","并行"],"title":"Actor模型","uri":"/myblog/actor%E6%A8%A1%E5%9E%8B/"},{"categories":["算法"],"content":"另外 邮箱中的消息根据分类可以设置处理的优先级 ","date":"2019-12-22","objectID":"/myblog/actor%E6%A8%A1%E5%9E%8B/:6:0","tags":["actor","并行"],"title":"Actor模型","uri":"/myblog/actor%E6%A8%A1%E5%9E%8B/"},{"categories":["web"],"content":"jwt管理用户登录态 —— 以expressjs和vuejs的前后端分离论坛项目作为实例 ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:0:0","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"session 很久很久以前，Web基本上就是文档的浏览而已 既然是浏览，作为服务器，不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议，就是请求加响应 尤其是我不用记住是谁刚刚发了HTTP请求，每个请求对我来说都是全新的。这段时间很嗨皮 但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统，哪些人往自己的购物车中放商品，也就是说我必须把每个人区分开，这就是一个不小的挑战， 因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id)，说白了就是一个随机的字串，每个人收到的都不一样，每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来，这样我就能区分开谁是谁了 流程 用户向服务器发送用户名和密码。 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色登录时间等等。 服务器向用户返回一个session_id，写入用户的Cookie。 用户随后的每一次请求，都会通过 Cookie，将session_id传回服务器。 服务器收到session_id，找到前期保存的数据，由此得知用户的身份。 这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id！如果访问服务器多了，就得由成千上万，甚至几十万个。 这对服务器说是一个巨大的开销，严重的限制了服务器扩展能力，比如说我用两个机器组成了一个集群，小F通过机器A登录了系统，那session id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？ 机器B可没有小F的session id啊。 有时候会采用一点小伎俩：session sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。 那只好做session的复制了，把session id在两个机器之间搬来搬去，快累死了。 后来有个叫Memcached的支了招： 把session id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session 的机器挂了，所有人都得重新登录一遍，估计得被人骂死 ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:1:0","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"token 于是有人就一直在思考，我为什么要保存这可恶的session呢，只让每个客户端去保存该多好？ 可是如果不保存这些session id，怎么验证客户端发给我的session id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法登录的用户，那些不怀好意的家伙们就可以伪造session id，为所欲为了。 嗯，对了，关键点就是验证 ！ 比如说，小F已经登录了系统，我给他发一个令牌(token)，里边包含了小F的user id，下一次小F再次通过Http请求访问我的时候，把这个token通过Http header带过来不就可以了。 不过这和session id没有本质区别啊，任何人都可以可以伪造，所以我得想点儿办法，让别人伪造不了。 那就对数据做一个签名吧，比如说我用SHA256算法，加上一个只有我才知道的密钥，对数据做一个签名，把这个签名和数据一起作为token，由于密钥别人不知道，就无法伪造token了。 这个token 我不保存，当小F把这个token 给我发过来的时候，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名，和token 中的签名做个比较，如果相同，我就知道小F已经登录过了，并且可以直接取到小F的user id，如果不相同，数据部分肯定被人篡改过，我就告诉发送者：对不起，没有认证。 Token 中的数据是明文保存的（虽然我会用Base64做下编码，但那不是加密），还是可以被别人看到的，所以我不能在其中保存像密码这样的敏感信息。 当然，如果一个人的token被别人偷走了，那我也没办法，我也会认为小偷就是合法用户，这其实和一个人的session id被别人偷走是一样的。 这样一来，我就不保存session id了，我只是生成token，然后验证token，我用我的CPU计算时间获取了我的session存储空间 ！ ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:2:0","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"cookie cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。 cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。 由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。 ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:3:0","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"Token的身份验证 流程 用户通过用户名和密码发送请求。 程序验证。 程序返回一个签名的token 给客户端。 客户端储存token，并且每次用于每次发送请求。 服务端验证token并返回数据。 ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:4:0","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"JWT JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。 ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:5:0","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"JWT的原理 JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。 JWT 的数据结构 它是一个很长的字符串，中间用点（.）分隔成三个部分。 JWT 的三个部分依次如下。 Header 部分是一个 JSON 对象，描述 JWT 的元数据， Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段供选用。 Signature 部分是对前两部分的签名，防止数据篡改。 ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:5:1","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"项目实例 我们现在看下项目中的应用实例 ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:6:0","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"生成token 先来看看后端是如何生成一个token的 router.post(\"/login\", async function(req, res, next) { const { username, password } = req.body; const userinfo_pw = await query(my_user_info_with_password, [username]); const md5_pw = md5(password); if (userinfo_pw.length === 0) { res.json({ code: 4001, msg: \"no such user\" }); } else if (md5_pw === userinfo_pw[0].password) { const token = jwt.sign( { iss: \"joyinn\", aud: username, uid: userinfo_pw[0].uid }, myconfig.jwtSecret, { // 授权时效1day expiresIn: 60 * 60 * 24 } ); // update last login time await query(update_logintime, [userinfo_pw[0].uid]); // get userinfo const userinfo = await query(my_user_info, [username]); res.json({ code: 0, msg: \"login ok\", token, user: userinfo[0] }); } else { res.json({ code: 4002, msg: \"wrong password\" }); } }); 当响应login handler，比对密码正确后，调用jsonwebtoken依赖库生成token const jwt = require(\"jsonwebtoken\"); const token = jwt.sign( { iss: \"joyinn\", aud: username, uid: userinfo_pw[0].uid }, myconfig.jwtSecret, { // 授权时效1day expiresIn: 60 * 60 * 24 } ); 这里jwt.sign(payload, secretOrPrivateKey, [options, callback])，具体文档可以参考jsonwebtoken ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:6:1","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"判断token正确性 依旧是后端，我们怎么判断用户的请求携带的登录态信息是正确的 根据上面陈述的token原理，我们只需要利用secret对JWT的前两段加密得到签名，比对JWT给出的签名即可 具体实现我们可以采用express-jwt依赖库，会对headers中的Authorization字段的token进行检验 // filename: app.js const expressJWT = require(\"express-jwt\"); // ... other code // 设置允许跨域访问该服务. app.use(function(req, res, next) { res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Methods\", \"GET,HEAD,OPTIONS,POST,PUT\"); res.header( \"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization\" ); next(); }); // jwt auth app.use( expressJWT({ secret: myconfig.jwtSecret }).unless({ path: [ \"/user/login\", \"/user/register\", \"/user/mailtozju\", \"/user/checkvalidcode\" ] //除了这个地址，其他的URL都需要验证 }) ); 我们这里将jwt验证中间件放在url响应函数之前，同时通过unless参数设置不需要jwt检验的api，实现了一个拦截层中间件 ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:6:2","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"访问jwt内部payload 中间件会将验证解析好的数据放在request里面，比如我们在handler里面可以通过req.user访问到token的所有信息 // post one say router.post(\"/\", async (req, res) =\u003e { const { photo, say_text } = req.body; const uid = req.user.uid; console.log(req.user); const photoNum = JSON.parse(photo).length; console.log(\"photoNum\", photoNum); let type; if (photoNum === 0) type = 0; else if (say_text === \"\") type = 1; else type = 2; const insertResult = await query(post_say, [type, say_text, photo, uid, 1]); res.json({ code: 0, msg: \"insert success\", insertId: insertResult.insertId }); }); ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:6:3","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"前端http通信的设置 这里我的实例项目是vuejs，http通信采用了axios，作为一个plugin被调用 我们为了实现jwt加载，需要在发送数据包和接收数据包的时候均对axios模块添加一些逻辑 // 在发送之前检查localstorage里面有无token字段，如果有就写入Authorization字段 _axios.interceptors.request.use( function(config) { const my_token = window.localStorage.getItem(\"token\"); if (my_token) { config.headers[\"Authorization\"] = `Bearer ${my_token}`; } return config; }, function(error) { return Promise.reject(error); } ); // 在收到以后检查response中有无token字段，如果有就将token写入到localstorage中 // 如果响应发生了错误（一般是由于在未登录状态下访问api、或者token有误导致被express-jwt拦截） // 那么就移除token并且跳转到登录页面 _axios.interceptors.response.use( function(response) { if (response.data.token) { window.localStorage.setItem(\"token\", response.data.token); } return response; }, function(error) { const errRes = error.response; if (errRes.status === 401) { window.localStorage.removeItem(\"token\"); router.push(\"/login\"); } return Promise.reject(error); } ); 我对vue默认的axios plugin做了二次封装，添加了传入自定义config以及token支持，详细代码可见gist ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:6:4","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"bonus: 路由守卫 我们有了用户登录态，对vue路由守卫实践起来自然就容易了 Vue.use(Router); let router = new Router({ mode: \"history\", base: process.env.BASE_URL, routes: [ { path: \"/\", name: \"home\", component: Home, meta: { requireAuth: true } }, { path: \"/login\", name: \"login\", component: Login, meta: { requireAuth: false } }, // ... more routes ] }); router.beforeEach((to, from, next) =\u003e { const token = localStorage.getItem(\"token\") || null; if (to.matched.some(record =\u003e record.meta.requireAuth)) { if (!Auth.loggedIn(token)) { next(\"/login\"); } else { if (!store.state.user.isLogin) { axios.get(\"/user/getuserinfo\").then(res =\u003e { store.dispatch(\"setUser\", res.data.user); next(); }); } else next(); } } else if (to.path === \"/login\" \u0026\u0026 Auth.loggedIn(token)) { next(\"/\"); } else { next(); } }); export default router; 我们对路由的meta对象加入requireAuth，设置布尔值表示是否需要路由守卫 接下来在router.beforeEach函数中对token进行检验，剩余对state更新以及路由跳转等逻辑我想不需要再赘述 ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:6:5","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"btw 如果对这一工程实例感兴趣的话可以查看joyinn 这是一个论坛的demo，采用expressjs+mysql+vue全家桶，说不定你能有所启发呢！ ","date":"2019-04-13","objectID":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/:6:6","tags":["cookie","session","token"],"title":"基于JWT的用户登录态管理","uri":"/myblog/%E5%9F%BA%E4%BA%8Ejwt%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81%E7%AE%A1%E7%90%86/"},{"categories":["web"],"content":"这次的文章主题是svg，预备知识基本是没有的 有几个应用过程中遇到的bug，po出来供大家参考避免走同样的弯路。 最近写了个社团的秋纳报名表，刚好UI设计人员给的设计稿有svg切图，以前从来没有接触过svg，这次有时间就尝试了一下，感觉还不错，虽然对低版本浏览器的兼容性是真的差 svg最大的优点就是矢量，资源体积很小，但是显示效果非常棒，对各种大小屏幕的适配性也是极其ok，耗费的主要是即时的计算和渲染 百度或者google一下，很容易找到关于svg的文档，也很容易找到关于svg嵌入html的几种方式的介绍 目前兼容性最好的是embed，不过调整大小我觉得麻烦，最后我还是直接用的svg标签形式嵌入网页。 \u003csvg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"100%\" height=\"100%\" viewBox=\"0 0 2000 2300\" \u003e \u003c!-- background --\u003e \u003cimage x=\"0\" y=\"0\" width=\"100%\" xlink:href=\"./static/Rectangle.svg\"\u003e\u003c/image\u003e \u003c!-- moon --\u003e \u003cimage id=\"moon2\" x=\"95%\" y=\"24%\" width=\"11%\" xlink:href=\"./static/Oval Copy 3.svg\"\u003e\u003c/image\u003e \u003cimage id=\"moon1\" x=\"-10%\" y=\"10%\" width=\"16%\" xlink:href=\"./static/Group.svg\"\u003e\u003c/image\u003e \u003cimage id=\"moon3\" x=\"80%\" y=\"63%\" width=\"14%\" xlink:href=\"./static/Oval Copy 3.svg\"\u003e\u003c/image\u003e \u003c!-- cloud --\u003e \u003cimage id=\"cloud1\" x=\"-8%\" y=\"23%\" width=\"16%\" xlink:href=\"./static/cloud1.svg\"\u003e\u003c/image\u003e \u003cimage id=\"cloud2\" x=\"45%\" y=\"-13%\" width=\"45%\" xlink:href=\"./static/cloud2.svg\"\u003e\u003c/image\u003e \u003cimage id=\"cloud3\" x=\"60%\" y=\"-13%\" width=\"35%\" xlink:href=\"./static/cloud3.svg\"\u003e\u003c/image\u003e \u003cimage id=\"cloud4\" x=\"95%\" y=\"35%\" width=\"10%\" xlink:href=\"./static/cloud4.svg\"\u003e\u003c/image\u003e \u003cimage id=\"cloud5\" x=\"30%\" y=\"61%\" width=\"18%\" xlink:href=\"./static/cloud5.svg\"\u003e\u003c/image\u003e \u003c!-- line --\u003e \u003cimage id=\"line\" x=\"0%\" y=\"2%\" width=\"100%\" xlink:href=\"./static/line.svg\"\u003e\u003c/image\u003e \u003c!-- title --\u003e \u003cimage id=\"title\" x=\"30%\" y=\"37%\" width=\"40%\" xlink:href=\"./static/UIslices/PAPIC.png\"\u003e\u003c/image\u003e \u003c!-- word --\u003e \u003ctext id=\"svgtext\" opacity=\"0\" x=\"32.5%\" y=\"48%\" fill=\"white\"\u003e浙大勤创秋季纳新\u003c/text\u003e \u003c!-- word-underline --\u003e \u003cline id=\"textline\" opacity=\"0\" x1=\"25%\" y1=\"41.5%\" x2=\"75%\" y2=\"41.5%\" stroke=\"white\" stroke-width=\"2\"/\u003e \u003c/svg\u003e php主体页面插入svg以及其子元素，链接css文件获取相应元素的动画代码 这样写在当代大多数浏览器上运行流畅，没有任何问题(不包括IE系列和edge) 但是到了各种机型的兼容性测试的时候，发现个别ios版本的微信和qq的内置浏览器无法运行，显示为一片空白 强烈吐槽腾讯的x5内核的浏览器！ 开始以为是浏览器版本低，不支持svg。不支持就显示静态图片咯！ 所以我添加了js代码在网页运行开始判断是否支持svg功能。如下： \u003cscript type=\"text/javascript\"\u003e $(document).ready(function(){ if (typeof SVGRect !== \"undefined\") { /* If the browser does support SVG. */ console.log(\"support svg!\"); //$(\"embed\").hide(); } else { /* If the browser does not support SVG. */ alert(\"do not support svg!\"); } }); \u003c/script\u003e 但是没用啊，所有的机子都告诉我他是支持svg的，真是打肿脸充胖子。气死！ 这里经过了漫长的搜索，baidu、bing、yahoo、google一个个搜过去，中间发现了一个提供各种浏览器版本对于各种功能的兼容性的信息网，收藏！https://caniuse.com/ 经过不断的尝试，发现最大的问题在于svg爸爸下面的image子标签，显示有问题；而其他建立的line、text标签毫无问题，只是因为颜色是白色，在背景不显示的情况下看不出来。 怎么办？ 继续google，不断改换关键字，各种尝试，无果，放弃，睡觉！ 最终解决这个问题的是js去动态渲染，这个方法成功解决了浏览器的兼容的问题，当然，我们不管IE9版本以下的破烂了。 这里推荐两个svg的js框架。分别是 svg.js 和 snap.svg。 我最后用的是svg.js，因为根据别人的博客写到，功能虽少些，但是兼容性更加好。自然选他了。 文档写的很明白，这里就不作更多关于这个框架的介绍了。确实方便，css3代码不用写了，网页dom树只要写好一个根节点，所有的渲染都通过js生成，恩很react。 下面展示一下我的简单动画所需的js代码 \u003cscript type=\"text/javascript\"\u003e $(document).ready(function() { var draw = SVG('mysvgbox').size('100%','100%'); var image = draw.image('static/Rectangle.png'); image.attr({x:0,y:0,id:'svgboxbgpic'}); image.size('100%'); $(\"#svgboxbgpic\").css('height','auto') var moon1 = draw.image('static/Group.svg'); moon1.attr({width:'16%',height:'16%',x:'-10%',y:'10%'}); moon1.animate({duration:1500}).move('20%','10%') .animate({duration:300}).move('22%','10%') .animate({duration:300}).move('20%','10%') .animate({duration:300}).move('22%','10%'); var moon2 = draw.image('static/Oval Copy 3.svg'); moon2.attr({width:'11%',height:'11%',x:'95%',y:'24%'}); moon2.animate({duration:3000}).move('65%','24%'); var moon3 = draw.image('static/Oval Copy 3.svg'); moon3.attr({width:'14%',height:'14%',x:'80%',y:'63%'}); var cloud1 = draw.image('static/cloud1.svg'); cloud1.attr({width:'18%',height:'30%',x:'-10%',y:'23%'}); cloud1.animate({duration:1500}).move('-2%','23%') .animate(300).move('-3%','23%') .animate(500).move('-1%','23%'); var cloud2 = draw.image('static/cloud2.svg'); cloud2.attr({width:'45%',height:'27%',x:'45%',y:'-13%'}); cloud2.animate(1500).move('45%','-2%') .animate(300).move('45%','-4%') .animate(500).move('45%','-2%'); var cloud3 = draw.image('static/clo","date":"2018-11-20","objectID":"/myblog/%E4%B8%8Esvg%E5%8A%A8%E7%94%BB%E7%BA%A0%E7%BC%A0%E4%B8%8D%E6%B8%85%E7%9A%84%E4%B8%A4%E5%A4%A9/:0:0","tags":["svg"],"title":"与svg动画纠缠不清的两天","uri":"/myblog/%E4%B8%8Esvg%E5%8A%A8%E7%94%BB%E7%BA%A0%E7%BC%A0%E4%B8%8D%E6%B8%85%E7%9A%84%E4%B8%A4%E5%A4%A9/"}]